/*!
 * @license
 * The MIT License (MIT)
 *
 * Copyright (c) 2012-2020 Bryce Neal
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
/******/var __webpack_modules__={
/***/731:
/***/(module,__unused_webpack_exports,__webpack_require__)=>{module.exports=__webpack_require__(297);
/***/},
/***/297:
/***/function(module,exports){var __WEBPACK_AMD_DEFINE_FACTORY__,__WEBPACK_AMD_DEFINE_ARRAY__,__WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0
(function(){var Heap,defaultCmp,floor,heapify,heappop,heappush,heappushpop,heapreplace,insort,min,nlargest,nsmallest,updateItem,_siftdown,_siftup;floor=Math.floor,min=Math.min,
/*
  Default comparison function to be used
   */
defaultCmp=function(x,y){return x<y?-1:x>y?1:0},
/*
  Insert item x in list a, and keep it sorted assuming a is sorted.
  
  If x is already in a, insert it to the right of the rightmost x.
  
  Optional args lo (default 0) and hi (default a.length) bound the slice
  of a to be searched.
   */
insort=function(a,x,lo,hi,cmp){var mid;if(null==lo&&(lo=0),null==cmp&&(cmp=defaultCmp),lo<0)throw new Error("lo must be non-negative");for(null==hi&&(hi=a.length);lo<hi;)cmp(x,a[mid=floor((lo+hi)/2)])<0?hi=mid:lo=mid+1;return[].splice.apply(a,[lo,lo-lo].concat(x)),x},
/*
  Push item onto heap, maintaining the heap invariant.
   */
heappush=function(array,item,cmp){return null==cmp&&(cmp=defaultCmp),array.push(item),_siftdown(array,0,array.length-1,cmp)},
/*
  Pop the smallest item off the heap, maintaining the heap invariant.
   */
heappop=function(array,cmp){var lastelt,returnitem;return null==cmp&&(cmp=defaultCmp),lastelt=array.pop(),array.length?(returnitem=array[0],array[0]=lastelt,_siftup(array,0,cmp)):returnitem=lastelt,returnitem},
/*
  Pop and return the current smallest value, and add the new item.
  
  This is more efficient than heappop() followed by heappush(), and can be
  more appropriate when using a fixed size heap. Note that the value
  returned may be larger than item! That constrains reasonable use of
  this routine unless written as part of a conditional replacement:
      if item > array[0]
        item = heapreplace(array, item)
   */
heapreplace=function(array,item,cmp){var returnitem;return null==cmp&&(cmp=defaultCmp),returnitem=array[0],array[0]=item,_siftup(array,0,cmp),returnitem},
/*
  Fast version of a heappush followed by a heappop.
   */
heappushpop=function(array,item,cmp){var _ref;return null==cmp&&(cmp=defaultCmp),array.length&&cmp(array[0],item)<0&&(item=(_ref=[array[0],item])[0],array[0]=_ref[1],_siftup(array,0,cmp)),item},
/*
  Transform list into a heap, in-place, in O(array.length) time.
   */
heapify=function(array,cmp){var i,_i,_len,_ref1,_results,_results1;for(null==cmp&&(cmp=defaultCmp),_ref1=function(){_results1=[];for(var _j=0,_ref=floor(array.length/2);0<=_ref?_j<_ref:_j>_ref;0<=_ref?_j++:_j--)_results1.push(_j);return _results1}.apply(this).reverse(),_results=[],_i=0,_len=_ref1.length;_i<_len;_i++)i=_ref1[_i],_results.push(_siftup(array,i,cmp));return _results},
/*
  Update the position of the given item in the heap.
  This function should be called every time the item is being modified.
   */
updateItem=function(array,item,cmp){var pos;if(null==cmp&&(cmp=defaultCmp),-1!==(pos=array.indexOf(item)))return _siftdown(array,0,pos,cmp),_siftup(array,pos,cmp)},
/*
  Find the n largest elements in a dataset.
   */
nlargest=function(array,n,cmp){var elem,result,_i,_len,_ref;if(null==cmp&&(cmp=defaultCmp),!(result=array.slice(0,n)).length)return result;for(heapify(result,cmp),_i=0,_len=(_ref=array.slice(n)).length;_i<_len;_i++)elem=_ref[_i],heappushpop(result,elem,cmp);return result.sort(cmp).reverse()},
/*
  Find the n smallest elements in a dataset.
   */
nsmallest=function(array,n,cmp){var elem,los,result,_i,_j,_len,_ref,_ref1,_results;if(null==cmp&&(cmp=defaultCmp),10*n<=array.length){if(!(result=array.slice(0,n).sort(cmp)).length)return result;for(los=result[result.length-1],_i=0,_len=(_ref=array.slice(n)).length;_i<_len;_i++)cmp(elem=_ref[_i],los)<0&&(insort(result,elem,0,null,cmp),result.pop(),los=result[result.length-1]);return result}for(heapify(array,cmp),_results=[],_j=0,_ref1=min(n,array.length);0<=_ref1?_j<_ref1:_j>_ref1;0<=_ref1?++_j:--_j)_results.push(heappop(array,cmp));return _results},_siftdown=function(array,startpos,pos,cmp){var newitem,parent,parentpos;for(null==cmp&&(cmp=defaultCmp),newitem=array[pos];pos>startpos&&cmp(newitem,parent=array[parentpos=pos-1>>1])<0;)array[pos]=parent,pos=parentpos;return array[pos]=newitem},_siftup=function(array,pos,cmp){var childpos,endpos,newitem,rightpos,startpos;for(null==cmp&&(cmp=defaultCmp),endpos=array.length,startpos=pos,newitem=array[pos],childpos=2*pos+1;childpos<endpos;)(rightpos=childpos+1)<endpos&&!(cmp(array[childpos],array[rightpos])<0)&&(childpos=rightpos),array[pos]=array[childpos],childpos=2*(pos=childpos)+1;return array[pos]=newitem,_siftdown(array,startpos,pos,cmp)},Heap=function(){function Heap(cmp){this.cmp=null!=cmp?cmp:defaultCmp,this.nodes=[]}return Heap.push=heappush,Heap.pop=heappop,Heap.replace=heapreplace,Heap.pushpop=heappushpop,Heap.heapify=heapify,Heap.updateItem=updateItem,Heap.nlargest=nlargest,Heap.nsmallest=nsmallest,Heap.prototype.push=function(x){return heappush(this.nodes,x,this.cmp)},Heap.prototype.pop=function(){return heappop(this.nodes,this.cmp)},Heap.prototype.peek=function(){return this.nodes[0]},Heap.prototype.contains=function(x){return-1!==this.nodes.indexOf(x)},Heap.prototype.replace=function(x){return heapreplace(this.nodes,x,this.cmp)},Heap.prototype.pushpop=function(x){return heappushpop(this.nodes,x,this.cmp)},Heap.prototype.heapify=function(){return heapify(this.nodes,this.cmp)},Heap.prototype.updateItem=function(x){return updateItem(this.nodes,x,this.cmp)},Heap.prototype.clear=function(){return this.nodes=[]},Heap.prototype.empty=function(){return 0===this.nodes.length},Heap.prototype.size=function(){return this.nodes.length},Heap.prototype.clone=function(){var heap;return(heap=new Heap).nodes=this.nodes.slice(0),heap},Heap.prototype.toArray=function(){return this.nodes.slice(0)},Heap.prototype.insert=Heap.prototype.push,Heap.prototype.top=Heap.prototype.peek,Heap.prototype.front=Heap.prototype.peek,Heap.prototype.has=Heap.prototype.contains,Heap.prototype.copy=Heap.prototype.clone,Heap}(),__WEBPACK_AMD_DEFINE_ARRAY__=[],void 0===(__WEBPACK_AMD_DEFINE_RESULT__="function"==typeof(__WEBPACK_AMD_DEFINE_FACTORY__=function(){return Heap})?__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,__WEBPACK_AMD_DEFINE_ARRAY__):__WEBPACK_AMD_DEFINE_FACTORY__)||(module.exports=__WEBPACK_AMD_DEFINE_RESULT__)}).call(this)}
/******/},__webpack_module_cache__={};
/************************************************************************/
/******/ // The module cache
/******/
/******/
/******/ // The require function
/******/function __webpack_require__(moduleId){
/******/ // Check if module is in cache
/******/var cachedModule=__webpack_module_cache__[moduleId];
/******/if(void 0!==cachedModule)
/******/return cachedModule.exports;
/******/
/******/ // Create a new module (and put it into the cache)
/******/var module=__webpack_module_cache__[moduleId]={
/******/ // no module.id needed
/******/ // no module.loaded needed
/******/exports:{}
/******/};
/******/
/******/ // Execute the module function
/******/
/******/
/******/ // Return the exports of the module
/******/return __webpack_modules__[moduleId].call(module.exports,module,module.exports,__webpack_require__),module.exports;
/******/}
/******/
/************************************************************************/
/******/ /* webpack/runtime/compat get default export */
/******/
/******/ // getDefaultExport function for compatibility with non-harmony modules
/******/__webpack_require__.n=module=>{
/******/var getter=module&&module.__esModule?
/******/()=>module.default
/******/:()=>module
/******/;
/******/return __webpack_require__.d(getter,{a:getter}),getter;
/******/},
/******/ // define getter functions for harmony exports
/******/__webpack_require__.d=(exports,definition)=>{
/******/for(var key in definition)
/******/__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&
/******/Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})
/******/;
/******/},
/******/__webpack_require__.o=(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop)
/******/,
/******/ // define __esModule on exports
/******/__webpack_require__.r=exports=>{
/******/"undefined"!=typeof Symbol&&Symbol.toStringTag&&
/******/Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"})
/******/,Object.defineProperty(exports,"__esModule",{value:!0})}
/******/;
/******/
/************************************************************************/
var __webpack_exports__={};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(()=>{
// EXPORTS
__webpack_require__.d(__webpack_exports__,{x:()=>/* binding */EasyStar});
// NAMESPACE OBJECT: ./src/instance.js
var instance_namespaceObject={};__webpack_require__.r(instance_namespaceObject);
// NAMESPACE OBJECT: ./src/node.js
var node_namespaceObject={};__webpack_require__.r(node_namespaceObject);
/**
* A simple Node that represents a single tile on the grid.
* @param {Object} parent The parent node.
* @param {Number} x The x position on the grid.
* @param {Number} y The y position on the grid.
* @param {Number} costSoFar How far this node is in moves*cost from the start.
* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.
**/
var heap=__webpack_require__(731),heap_default=__webpack_require__.n(heap),EasyStar={},nextInstanceId=1;
// EXTERNAL MODULE: ./node_modules/heap/index.js
EasyStar.js=function(){var collisionGrid,iterationsSoFar,acceptableTiles,syncEnabled=!1,pointsToAvoid={},costMap={},pointsToCost={},directionalConditions={},allowCornerCutting=!0,instances={},instanceQueue=[],iterationsPerCalculation=Number.MAX_VALUE,diagonalsEnabled=!1;
/**
  * Sets the collision grid that EasyStar uses.
  *
  * @param {Array|Number} tiles An array of numbers that represent
  * which tiles in your grid should be considered
  * acceptable, or "walkable".
  **/
this.setAcceptableTiles=function(tiles){tiles instanceof Array?
// Array
acceptableTiles=tiles:!isNaN(parseFloat(tiles))&&isFinite(tiles)&&(
// Number
acceptableTiles=[tiles])},
/**
  * Enables sync mode for this EasyStar instance..
  * if you're into that sort of thing.
  **/
this.enableSync=function(){syncEnabled=!0},
/**
  * Disables sync mode for this EasyStar instance.
  **/
this.disableSync=function(){syncEnabled=!1},
/**
   * Enable diagonal pathfinding.
   */
this.enableDiagonals=function(){diagonalsEnabled=!0},
/**
   * Disable diagonal pathfinding.
   */
this.disableDiagonals=function(){diagonalsEnabled=!1},
/**
  * Sets the collision grid that EasyStar uses.
  *
  * @param {Array} grid The collision grid that this EasyStar instance will read from.
  * This should be a 2D Array of Numbers.
  **/
this.setGrid=function(grid){collisionGrid=grid;
//Setup cost map
for(var y=0;y<collisionGrid.length;y++)for(var x=0;x<collisionGrid[0].length;x++)costMap[collisionGrid[y][x]]||(costMap[collisionGrid[y][x]]=1)},
/**
  * Sets the tile cost for a particular tile type.
  *
  * @param {Number} The tile type to set the cost for.
  * @param {Number} The multiplicative cost associated with the given tile.
  **/
this.setTileCost=function(tileType,cost){costMap[tileType]=cost},
/**
  * Sets the an additional cost for a particular point.
  * Overrides the cost from setTileCost.
  *
  * @param {Number} x The x value of the point to cost.
  * @param {Number} y The y value of the point to cost.
  * @param {Number} The multiplicative cost associated with the given point.
  **/
this.setAdditionalPointCost=function(x,y,cost){void 0===pointsToCost[y]&&(pointsToCost[y]={}),pointsToCost[y][x]=cost},
/**
  * Remove the additional cost for a particular point.
  *
  * @param {Number} x The x value of the point to stop costing.
  * @param {Number} y The y value of the point to stop costing.
  **/
this.removeAdditionalPointCost=function(x,y){void 0!==pointsToCost[y]&&delete pointsToCost[y][x]},
/**
  * Remove all additional point costs.
  **/
this.removeAllAdditionalPointCosts=function(){pointsToCost={}},
/**
  * Sets a directional condition on a tile
  *
  * @param {Number} x The x value of the point.
  * @param {Number} y The y value of the point.
  * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access
  * the tile.
  **/
this.setDirectionalCondition=function(x,y,allowedDirections){void 0===directionalConditions[y]&&(directionalConditions[y]={}),directionalConditions[y][x]=allowedDirections},
/**
  * Remove all directional conditions
  **/
this.removeAllDirectionalConditions=function(){directionalConditions={}},
/**
  * Sets the number of search iterations per calculation.
  * A lower number provides a slower result, but more practical if you
  * have a large tile-map and don't want to block your thread while
  * finding a path.
  *
  * @param {Number} iterations The number of searches to prefrom per calculate() call.
  **/
this.setIterationsPerCalculation=function(iterations){iterationsPerCalculation=iterations},
/**
  * Avoid a particular point on the grid,
  * regardless of whether or not it is an acceptable tile.
  *
  * @param {Number} x The x value of the point to avoid.
  * @param {Number} y The y value of the point to avoid.
  **/
this.avoidAdditionalPoint=function(x,y){void 0===pointsToAvoid[y]&&(pointsToAvoid[y]={}),pointsToAvoid[y][x]=1},
/**
  * Stop avoiding a particular point on the grid.
  *
  * @param {Number} x The x value of the point to stop avoiding.
  * @param {Number} y The y value of the point to stop avoiding.
  **/
this.stopAvoidingAdditionalPoint=function(x,y){void 0!==pointsToAvoid[y]&&delete pointsToAvoid[y][x]},
/**
  * Enables corner cutting in diagonal movement.
  **/
this.enableCornerCutting=function(){allowCornerCutting=!0},
/**
  * Disables corner cutting in diagonal movement.
  **/
this.disableCornerCutting=function(){allowCornerCutting=!1},
/**
  * Stop avoiding all additional points on the grid.
  **/
this.stopAvoidingAllAdditionalPoints=function(){pointsToAvoid={}},
/**
  * Find a path.
  *
  * @param {Number} startX The X position of the starting point.
  * @param {Number} startY The Y position of the starting point.
  * @param {Number} endX The X position of the ending point.
  * @param {Number} endY The Y position of the ending point.
  * @param {Function} callback A function that is called when your path
  * is found, or no path is found.
  * @return {Number} A numeric, non-zero value which identifies the created instance. This value can be passed to cancelPath to cancel the path calculation.
  *
  **/
this.findPath=function(startX,startY,endX,endY,callback){
// Wraps the callback for sync vs async logic
var callbackWrapper=function(result){syncEnabled?callback(result):setTimeout((function(){callback(result)}))};
// No acceptable tiles were set
if(void 0===acceptableTiles)throw new Error("You can't set a path without first calling setAcceptableTiles() on EasyStar.");
// No grid was set
if(void 0===collisionGrid)throw new Error("You can't set a path without first calling setGrid() on EasyStar.");
// Start or endpoint outside of scope.
if(startX<0||startY<0||endX<0||endY<0||startX>collisionGrid[0].length-1||startY>collisionGrid.length-1||endX>collisionGrid[0].length-1||endY>collisionGrid.length-1)throw new Error("Your start or end point is outside the scope of your grid.");
// Start and end are the same tile.
if(startX!==endX||startY!==endY){for(
// End point is not an acceptable tile.
var endTile=collisionGrid[endY][endX],isAcceptable=!1,i=0;i<acceptableTiles.length;i++)if(endTile===acceptableTiles[i]){isAcceptable=!0;break}if(!1!==isAcceptable){
// Create the instance
var instance=new instance_namespaceObject.default;instance.openList=new(heap_default())((function(nodeA,nodeB){return nodeA.bestGuessDistance()-nodeB.bestGuessDistance()})),instance.isDoneCalculating=!1,instance.nodeHash={},instance.startX=startX,instance.startY=startY,instance.endX=endX,instance.endY=endY,instance.callback=callbackWrapper,instance.openList.push(coordinateToNode(instance,instance.startX,instance.startY,null,1));var instanceId=nextInstanceId++;return instances[instanceId]=instance,instanceQueue.push(instanceId),instanceId}callbackWrapper(null)}else callbackWrapper([])},
/**
   * Cancel a path calculation.
   *
   * @param {Number} instanceId The instance ID of the path being calculated
   * @return {Boolean} True if an instance was found and cancelled.
   *
   **/
this.cancelPath=function(instanceId){return instanceId in instances&&(delete instances[instanceId],!0)},
/**
  * This method steps through the A* Algorithm in an attempt to
  * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.
  * You can change the number of calculations done in a call by using
  * easystar.setIteratonsPerCalculation().
  **/
this.calculate=function(){if(0!==instanceQueue.length&&void 0!==collisionGrid&&void 0!==acceptableTiles)for(iterationsSoFar=0;iterationsSoFar<iterationsPerCalculation;iterationsSoFar++){if(0===instanceQueue.length)return;syncEnabled&&(
// If this is a sync instance, we want to make sure that it calculates synchronously.
iterationsSoFar=0);var instanceId=instanceQueue[0],instance=instances[instanceId];if(void 0!==instance)
// Couldn't find a path.
if(0!==instance.openList.size()){var searchNode=instance.openList.pop();
// Handles the case where we have found the destination
if(instance.endX!==searchNode.x||instance.endY!==searchNode.y)searchNode.list=0,searchNode.y>0&&checkAdjacentNode(instance,searchNode,0,-1,1*getTileCost(searchNode.x,searchNode.y-1)),searchNode.x<collisionGrid[0].length-1&&checkAdjacentNode(instance,searchNode,1,0,1*getTileCost(searchNode.x+1,searchNode.y)),searchNode.y<collisionGrid.length-1&&checkAdjacentNode(instance,searchNode,0,1,1*getTileCost(searchNode.x,searchNode.y+1)),searchNode.x>0&&checkAdjacentNode(instance,searchNode,-1,0,1*getTileCost(searchNode.x-1,searchNode.y)),diagonalsEnabled&&(searchNode.x>0&&searchNode.y>0&&(allowCornerCutting||isTileWalkable(collisionGrid,acceptableTiles,searchNode.x,searchNode.y-1,searchNode)&&isTileWalkable(collisionGrid,acceptableTiles,searchNode.x-1,searchNode.y,searchNode))&&checkAdjacentNode(instance,searchNode,-1,-1,1.4*getTileCost(searchNode.x-1,searchNode.y-1)),searchNode.x<collisionGrid[0].length-1&&searchNode.y<collisionGrid.length-1&&(allowCornerCutting||isTileWalkable(collisionGrid,acceptableTiles,searchNode.x,searchNode.y+1,searchNode)&&isTileWalkable(collisionGrid,acceptableTiles,searchNode.x+1,searchNode.y,searchNode))&&checkAdjacentNode(instance,searchNode,1,1,1.4*getTileCost(searchNode.x+1,searchNode.y+1)),searchNode.x<collisionGrid[0].length-1&&searchNode.y>0&&(allowCornerCutting||isTileWalkable(collisionGrid,acceptableTiles,searchNode.x,searchNode.y-1,searchNode)&&isTileWalkable(collisionGrid,acceptableTiles,searchNode.x+1,searchNode.y,searchNode))&&checkAdjacentNode(instance,searchNode,1,-1,1.4*getTileCost(searchNode.x+1,searchNode.y-1)),searchNode.x>0&&searchNode.y<collisionGrid.length-1&&(allowCornerCutting||isTileWalkable(collisionGrid,acceptableTiles,searchNode.x,searchNode.y+1,searchNode)&&isTileWalkable(collisionGrid,acceptableTiles,searchNode.x-1,searchNode.y,searchNode))&&checkAdjacentNode(instance,searchNode,-1,1,1.4*getTileCost(searchNode.x-1,searchNode.y+1)));else{var path=[];path.push({x:searchNode.x,y:searchNode.y});for(var parent=searchNode.parent;null!=parent;)path.push({x:parent.x,y:parent.y}),parent=parent.parent;path.reverse();var ip=path;instance.callback(ip),delete instances[instanceId],instanceQueue.shift()}}else instance.callback(null),delete instances[instanceId],instanceQueue.shift();else
// This instance was cancelled
instanceQueue.shift()}};
// Private methods follow
var checkAdjacentNode=function(instance,searchNode,x,y,cost){var adjacentCoordinateX=searchNode.x+x,adjacentCoordinateY=searchNode.y+y;if((void 0===pointsToAvoid[adjacentCoordinateY]||void 0===pointsToAvoid[adjacentCoordinateY][adjacentCoordinateX])&&isTileWalkable(collisionGrid,acceptableTiles,adjacentCoordinateX,adjacentCoordinateY,searchNode)){var node=coordinateToNode(instance,adjacentCoordinateX,adjacentCoordinateY,searchNode,cost);void 0===node.list?(node.list=1,instance.openList.push(node)):searchNode.costSoFar+cost<node.costSoFar&&(node.costSoFar=searchNode.costSoFar+cost,node.parent=searchNode,instance.openList.updateItem(node))}},isTileWalkable=function(collisionGrid,acceptableTiles,x,y,sourceNode){var directionalCondition=directionalConditions[y]&&directionalConditions[y][x];if(directionalCondition){var direction=calculateDirection(sourceNode.x-x,sourceNode.y-y);if(!function(){for(var i=0;i<directionalCondition.length;i++)if(directionalCondition[i]===direction)return!0;return!1}())return!1}for(var i=0;i<acceptableTiles.length;i++)if(collisionGrid[y][x]===acceptableTiles[i])return!0;return!1},calculateDirection=function(diffX,diffY){if(0===diffX&&-1===diffY)return EasyStar.TOP;if(1===diffX&&-1===diffY)return EasyStar.TOP_RIGHT;if(1===diffX&&0===diffY)return EasyStar.RIGHT;if(1===diffX&&1===diffY)return EasyStar.BOTTOM_RIGHT;if(0===diffX&&1===diffY)return EasyStar.BOTTOM;if(-1===diffX&&1===diffY)return EasyStar.BOTTOM_LEFT;if(-1===diffX&&0===diffY)return EasyStar.LEFT;if(-1===diffX&&-1===diffY)return EasyStar.TOP_LEFT;throw new Error("These differences are not valid: "+diffX+", "+diffY)},getTileCost=function(x,y){return pointsToCost[y]&&pointsToCost[y][x]||costMap[collisionGrid[y][x]]},coordinateToNode=function(instance,x,y,parent,cost){if(void 0!==instance.nodeHash[y]){if(void 0!==instance.nodeHash[y][x])return instance.nodeHash[y][x]}else instance.nodeHash[y]={};var simpleDistanceToTarget=getDistance(x,y,instance.endX,instance.endY);if(null!==parent)var costSoFar=parent.costSoFar+cost;else costSoFar=0;var node=new node_namespaceObject.default(parent,x,y,costSoFar,simpleDistanceToTarget);return instance.nodeHash[y][x]=node,node},getDistance=function(x1,y1,x2,y2){
// Octile distance
var dx,dy;return diagonalsEnabled?(dx=Math.abs(x1-x2))<(dy=Math.abs(y1-y2))?1.4*dx+dy:1.4*dy+dx:(dx=Math.abs(x1-x2))+(dy=Math.abs(y1-y2))};
// Helpers
},EasyStar.TOP="TOP",EasyStar.TOP_RIGHT="TOP_RIGHT",EasyStar.RIGHT="RIGHT",EasyStar.BOTTOM_RIGHT="BOTTOM_RIGHT",EasyStar.BOTTOM="BOTTOM",EasyStar.BOTTOM_LEFT="BOTTOM_LEFT",EasyStar.LEFT="LEFT",EasyStar.TOP_LEFT="TOP_LEFT"})();var __webpack_exports__EasyStar=__webpack_exports__.x;export{__webpack_exports__EasyStar as EasyStar};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWFzeXN0YXItMC40LjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7NkRBQUFBLE9BQU9DLFFBQVUsb0JBQWpCOzs7OEJDQUE7Q0FDQSxXQUNFLElBQUlDLEtBQU1DLFdBQVlDLE1BQU9DLFFBQVNDLFFBQVNDLFNBQVVDLFlBQWFDLFlBQWFDLE9BQVFDLElBQUtDLFNBQVVDLFVBQVdDLFdBQVlDLFVBQVdDLFFBRTVJWixNQUFRYSxLQUFLYixNQUFPTyxJQUFNTSxLQUFLTjs7OztBQU8vQlIsV0FBYSxTQUFTZSxFQUFHQyxHQUN2QixPQUFJRCxFQUFJQyxHQUNFLEVBRU5ELEVBQUlDLEVBQ0MsRUFFRixDQUNUOzs7Ozs7Ozs7QUFZQVQsT0FBUyxTQUFTVSxFQUFHRixFQUFHRyxHQUFJQyxHQUFJQyxLQUM5QixJQUFJQyxJQU9KLEdBTlUsTUFBTkgsS0FDRkEsR0FBSyxHQUVJLE1BQVBFLE1BQ0ZBLElBQU1wQixZQUVKa0IsR0FBSyxFQUNQLE1BQU0sSUFBSUksTUFBTSwyQkFLbEIsSUFIVSxNQUFOSCxLQUNGQSxHQUFLRixFQUFFTSxRQUVGTCxHQUFLQyxJQUVOQyxJQUFJTCxFQUFHRSxFQURYSSxJQUFNcEIsT0FBT2lCLEdBQUtDLElBQU0sS0FDSCxFQUNuQkEsR0FBS0UsSUFFTEgsR0FBS0csSUFBTSxFQUdmLE1BQVEsR0FBR0csT0FBT0MsTUFBTVIsRUFBRyxDQUFDQyxHQUFJQSxHQUFLQSxJQUFJUSxPQUFPWCxJQUFLQSxDQUN2RDs7OztBQU9BWCxTQUFXLFNBQVN1QixNQUFPQyxLQUFNUixLQUsvQixPQUpXLE1BQVBBLE1BQ0ZBLElBQU1wQixZQUVSMkIsTUFBTUUsS0FBS0QsTUFDSmhCLFVBQVVlLE1BQU8sRUFBR0EsTUFBTUosT0FBUyxFQUFHSCxJQUMvQzs7OztBQU9BakIsUUFBVSxTQUFTd0IsTUFBT1AsS0FDeEIsSUFBSVUsUUFBU0MsV0FZYixPQVhXLE1BQVBYLE1BQ0ZBLElBQU1wQixZQUVSOEIsUUFBVUgsTUFBTUssTUFDWkwsTUFBTUosUUFDUlEsV0FBYUosTUFBTSxHQUNuQkEsTUFBTSxHQUFLRyxRQUNYakIsUUFBUWMsTUFBTyxFQUFHUCxNQUVsQlcsV0FBYUQsUUFFUkMsVUFDVDs7Ozs7Ozs7Ozs7QUFjQXpCLFlBQWMsU0FBU3FCLE1BQU9DLEtBQU1SLEtBQ2xDLElBQUlXLFdBT0osT0FOVyxNQUFQWCxNQUNGQSxJQUFNcEIsWUFFUitCLFdBQWFKLE1BQU0sR0FDbkJBLE1BQU0sR0FBS0MsS0FDWGYsUUFBUWMsTUFBTyxFQUFHUCxLQUNYVyxVQUNUOzs7O0FBT0ExQixZQUFjLFNBQVNzQixNQUFPQyxLQUFNUixLQUNsQyxJQUFJYSxLQVFKLE9BUFcsTUFBUGIsTUFDRkEsSUFBTXBCLFlBRUoyQixNQUFNSixRQUFVSCxJQUFJTyxNQUFNLEdBQUlDLE1BQVEsSUFDZkEsTUFBekJLLEtBQU8sQ0FBQ04sTUFBTSxHQUFJQyxPQUFtQixHQUFJRCxNQUFNLEdBQUtNLEtBQUssR0FDekRwQixRQUFRYyxNQUFPLEVBQUdQLE1BRWJRLElBQ1Q7Ozs7QUFPQTFCLFFBQVUsU0FBU3lCLE1BQU9QLEtBQ3hCLElBQUljLEVBQUdDLEdBQVFDLEtBQVlDLE1BQU9DLFNBQVVDLFVBVTVDLElBVFcsTUFBUG5CLE1BQ0ZBLElBQU1wQixZQUVScUMsTUFBUSxXQUNORSxVQUFZLEdBQ1osSUFBSyxJQUFJQyxHQUFLLEVBQUdQLEtBQU9oQyxNQUFNMEIsTUFBTUosT0FBUyxHQUFJLEdBQUtVLEtBQU9PLEdBQUtQLEtBQU9PLEdBQUtQLEtBQU0sR0FBS0EsS0FBT08sS0FBT0EsS0FBT0QsVUFBVVYsS0FBS1csSUFDN0gsT0FBT0QsU0FDUixFQUFFZCxNQUFNZ0IsTUFBTUMsVUFDZkosU0FBVyxHQUNOSCxHQUFLLEVBQUdDLEtBQU9DLE1BQU1kLE9BQVFZLEdBQUtDLEtBQU1ELEtBQzNDRCxFQUFJRyxNQUFNRixJQUNWRyxTQUFTVCxLQUFLaEIsUUFBUWMsTUFBT08sRUFBR2QsTUFFbEMsT0FBT2tCLFFBQ1Q7Ozs7O0FBUUEzQixXQUFhLFNBQVNnQixNQUFPQyxLQUFNUixLQUNqQyxJQUFJdUIsSUFLSixHQUpXLE1BQVB2QixNQUNGQSxJQUFNcEIsYUFHSyxLQURiMkMsSUFBTWhCLE1BQU1pQixRQUFRaEIsT0FLcEIsT0FEQWhCLFVBQVVlLE1BQU8sRUFBR2dCLElBQUt2QixLQUNsQlAsUUFBUWMsTUFBT2dCLElBQUt2QixJQUM3Qjs7OztBQU9BWCxTQUFXLFNBQVNrQixNQUFPa0IsRUFBR3pCLEtBQzVCLElBQUkwQixLQUFNQyxPQUFRWixHQUFJQyxLQUFNSCxLQUs1QixHQUpXLE1BQVBiLE1BQ0ZBLElBQU1wQixjQUVSK0MsT0FBU3BCLE1BQU1xQixNQUFNLEVBQUdILElBQ1p0QixPQUNWLE9BQU93QixPQUlULElBRkE3QyxRQUFRNkMsT0FBUTNCLEtBRVhlLEdBQUssRUFBR0MsTUFEYkgsS0FBT04sTUFBTXFCLE1BQU1ILElBQ010QixPQUFRWSxHQUFLQyxLQUFNRCxLQUMxQ1csS0FBT2IsS0FBS0UsSUFDWjlCLFlBQVkwQyxPQUFRRCxLQUFNMUIsS0FFNUIsT0FBTzJCLE9BQU9FLEtBQUs3QixLQUFLc0IsU0FDMUI7Ozs7QUFPQWhDLFVBQVksU0FBU2lCLE1BQU9rQixFQUFHekIsS0FDN0IsSUFBSTBCLEtBQVNJLElBQUtILE9BQVFaLEdBQUlLLEdBQUlKLEtBQU1ILEtBQU1JLE1BQU9DLFNBSXJELEdBSFcsTUFBUGxCLE1BQ0ZBLElBQU1wQixZQUVBLEdBQUo2QyxHQUFVbEIsTUFBTUosT0FBUSxDQUUxQixLQURBd0IsT0FBU3BCLE1BQU1xQixNQUFNLEVBQUdILEdBQUdJLEtBQUs3QixNQUNwQkcsT0FDVixPQUFPd0IsT0FJVCxJQUZBRyxJQUFNSCxPQUFPQSxPQUFPeEIsT0FBUyxHQUV4QlksR0FBSyxFQUFHQyxNQURiSCxLQUFPTixNQUFNcUIsTUFBTUgsSUFDTXRCLE9BQVFZLEdBQUtDLEtBQU1ELEtBRXRDZixJQURKMEIsS0FBT2IsS0FBS0UsSUFDRWUsS0FBTyxJQUNuQjNDLE9BQU93QyxPQUFRRCxLQUFNLEVBQUcsS0FBTTFCLEtBQzlCMkIsT0FBT2YsTUFDUGtCLElBQU1ILE9BQU9BLE9BQU94QixPQUFTLElBR2pDLE9BQU93QixNQUNULENBR0EsSUFGQTdDLFFBQVF5QixNQUFPUCxLQUNma0IsU0FBVyxHQUNGRSxHQUFLLEVBQUdILE1BQVE3QixJQUFJcUMsRUFBR2xCLE1BQU1KLFFBQVMsR0FBS2MsTUFBUUcsR0FBS0gsTUFBUUcsR0FBS0gsTUFBVyxHQUFLQSxRQUFVRyxLQUFPQSxHQUM3R0YsU0FBU1QsS0FBSzFCLFFBQVF3QixNQUFPUCxNQUUvQixPQUFPa0IsUUFDVCxFQUVBMUIsVUFBWSxTQUFTZSxNQUFPd0IsU0FBVVIsSUFBS3ZCLEtBQ3pDLElBQUlnQyxRQUFTQyxPQUFRQyxVQUtyQixJQUpXLE1BQVBsQyxNQUNGQSxJQUFNcEIsWUFFUm9ELFFBQVV6QixNQUFNZ0IsS0FDVEEsSUFBTVEsVUFHUC9CLElBQUlnQyxRQURSQyxPQUFTMUIsTUFEVDJCLFVBQWFYLElBQU0sR0FBTSxJQUVFLEdBQ3pCaEIsTUFBTWdCLEtBQU9VLE9BQ2JWLElBQU1XLFVBS1YsT0FBTzNCLE1BQU1nQixLQUFPUyxPQUN0QixFQUVBdkMsUUFBVSxTQUFTYyxNQUFPZ0IsSUFBS3ZCLEtBQzdCLElBQUltQyxTQUFVQyxPQUFRSixRQUFTSyxTQUFVTixTQVF6QyxJQVBXLE1BQVAvQixNQUNGQSxJQUFNcEIsWUFFUndELE9BQVM3QixNQUFNSixPQUNmNEIsU0FBV1IsSUFDWFMsUUFBVXpCLE1BQU1nQixLQUNoQlksU0FBVyxFQUFJWixJQUFNLEVBQ2RZLFNBQVdDLFNBQ2hCQyxTQUFXRixTQUFXLEdBQ1BDLFVBQVlwQyxJQUFJTyxNQUFNNEIsVUFBVzVCLE1BQU04QixXQUFhLEtBQ2pFRixTQUFXRSxVQUViOUIsTUFBTWdCLEtBQU9oQixNQUFNNEIsVUFFbkJBLFNBQVcsR0FEWFosSUFBTVksVUFDZSxFQUd2QixPQURBNUIsTUFBTWdCLEtBQU9TLFFBQ054QyxVQUFVZSxNQUFPd0IsU0FBVVIsSUFBS3ZCLElBQ3pDLEVBRUFyQixLQUFPLFdBaUJMLFNBQVNBLEtBQUtxQixLQUNacUIsS0FBS3JCLElBQWEsTUFBUEEsSUFBY0EsSUFBTXBCLFdBQy9CeUMsS0FBS2lCLE1BQVEsRUFDZixDQW1FQSxPQXRGQTNELEtBQUs4QixLQUFPekIsU0FFWkwsS0FBS2lDLElBQU03QixRQUVYSixLQUFLNEQsUUFBVXJELFlBRWZQLEtBQUs2RCxRQUFVdkQsWUFFZk4sS0FBS0csUUFBVUEsUUFFZkgsS0FBS1ksV0FBYUEsV0FFbEJaLEtBQUtVLFNBQVdBLFNBRWhCVixLQUFLVyxVQUFZQSxVQU9qQlgsS0FBSzhELFVBQVVoQyxLQUFPLFNBQVNkLEdBQzdCLE9BQU9YLFNBQVNxQyxLQUFLaUIsTUFBTzNDLEVBQUcwQixLQUFLckIsSUFDdEMsRUFFQXJCLEtBQUs4RCxVQUFVN0IsSUFBTSxXQUNuQixPQUFPN0IsUUFBUXNDLEtBQUtpQixNQUFPakIsS0FBS3JCLElBQ2xDLEVBRUFyQixLQUFLOEQsVUFBVUMsS0FBTyxXQUNwQixPQUFPckIsS0FBS2lCLE1BQU0sRUFDcEIsRUFFQTNELEtBQUs4RCxVQUFVRSxTQUFXLFNBQVNoRCxHQUNqQyxPQUFrQyxJQUEzQjBCLEtBQUtpQixNQUFNZCxRQUFRN0IsRUFDNUIsRUFFQWhCLEtBQUs4RCxVQUFVRixRQUFVLFNBQVM1QyxHQUNoQyxPQUFPVCxZQUFZbUMsS0FBS2lCLE1BQU8zQyxFQUFHMEIsS0FBS3JCLElBQ3pDLEVBRUFyQixLQUFLOEQsVUFBVUQsUUFBVSxTQUFTN0MsR0FDaEMsT0FBT1YsWUFBWW9DLEtBQUtpQixNQUFPM0MsRUFBRzBCLEtBQUtyQixJQUN6QyxFQUVBckIsS0FBSzhELFVBQVUzRCxRQUFVLFdBQ3ZCLE9BQU9BLFFBQVF1QyxLQUFLaUIsTUFBT2pCLEtBQUtyQixJQUNsQyxFQUVBckIsS0FBSzhELFVBQVVsRCxXQUFhLFNBQVNJLEdBQ25DLE9BQU9KLFdBQVc4QixLQUFLaUIsTUFBTzNDLEVBQUcwQixLQUFLckIsSUFDeEMsRUFFQXJCLEtBQUs4RCxVQUFVRyxNQUFRLFdBQ3JCLE9BQU92QixLQUFLaUIsTUFBUSxFQUN0QixFQUVBM0QsS0FBSzhELFVBQVVJLE1BQVEsV0FDckIsT0FBNkIsSUFBdEJ4QixLQUFLaUIsTUFBTW5DLE1BQ3BCLEVBRUF4QixLQUFLOEQsVUFBVUssS0FBTyxXQUNwQixPQUFPekIsS0FBS2lCLE1BQU1uQyxNQUNwQixFQUVBeEIsS0FBSzhELFVBQVVNLE1BQVEsV0FDckIsSUFBSUMsS0FHSixPQUZBQSxLQUFPLElBQUlyRSxNQUNOMkQsTUFBUWpCLEtBQUtpQixNQUFNVixNQUFNLEdBQ3ZCb0IsSUFDVCxFQUVBckUsS0FBSzhELFVBQVVRLFFBQVUsV0FDdkIsT0FBTzVCLEtBQUtpQixNQUFNVixNQUFNLEVBQzFCLEVBRUFqRCxLQUFLOEQsVUFBVVMsT0FBU3ZFLEtBQUs4RCxVQUFVaEMsS0FFdkM5QixLQUFLOEQsVUFBVVUsSUFBTXhFLEtBQUs4RCxVQUFVQyxLQUVwQy9ELEtBQUs4RCxVQUFVVyxNQUFRekUsS0FBSzhELFVBQVVDLEtBRXRDL0QsS0FBSzhELFVBQVVZLElBQU0xRSxLQUFLOEQsVUFBVUUsU0FFcENoRSxLQUFLOEQsVUFBVWEsS0FBTzNFLEtBQUs4RCxVQUFVTSxNQUU5QnBFLElBRVIsQ0F6Rk0sR0E2RkksNkJBQU8sUUFBVyxzREFBUCwrQkFNYixXQUNQLE9BQU9BLElBQ1QsR0FSNkIsMEpBVTlCLEdBQUU0RSxLQUFLbEMsSztVQ3JYSm1DLHlCQUEyQixDQUFDOzs7Ozs7UUFHaEMsU0FBU0Msb0JBQW9CQzs7UUFFNUIsSUFBSUMsYUFBZUgseUJBQXlCRTtRQUM1QyxRQUFxQkUsSUFBakJEO1FBQ0gsT0FBT0EsYUFBYWpGOzs7UUFHckIsSUFBSUQsT0FBUytFLHlCQUF5QkUsVUFBWTs7O1FBR2pEaEYsUUFBUyxDQUFDOzs7Ozs7O1FBT1gsT0FIQW1GLG9CQUFvQkgsVUFBVUgsS0FBSzlFLE9BQU9DLFFBQVNELE9BQVFBLE9BQU9DLFFBQVMrRSxxQkFHcEVoRixPQUFPQztRQUNmOzs7Ozs7UUNyQkErRSxvQkFBb0JoQyxFQUFLaEQ7UUFDeEIsSUFBSXFGLE9BQVNyRixRQUFVQSxPQUFPc0Y7UUFDN0IsSUFBT3RGLE9BQWlCO1NBQ3hCLElBQU07O1FBRVAsT0FEQWdGLG9CQUFvQk8sRUFBRUYsT0FBUSxDQUFFakUsRUFBR2lFLFNBQzVCQTtRQUFNOztRQ0xkTCxvQkFBb0JPLEVBQUksQ0FBQ3RGLFFBQVN1RjtRQUNqQyxJQUFJLElBQUlDLE9BQU9EO1FBQ1hSLG9CQUFvQlUsRUFBRUYsV0FBWUMsT0FBU1Qsb0JBQW9CVSxFQUFFekYsUUFBU3dGO1FBQzVFRSxPQUFPQyxlQUFlM0YsUUFBU3dGLElBQUssQ0FBRUksWUFBWSxFQUFNQyxJQUFLTixXQUFXQzs7UUFFMUU7UUNORFQsb0JBQW9CVSxFQUFJLENBQUNLLElBQUtDLE9BQVVMLE9BQU8zQixVQUFVaUMsZUFBZW5CLEtBQUtpQixJQUFLQzs7O1FDQ2xGaEIsb0JBQW9Ca0IsRUFBS2pHO1FBQ0gsb0JBQVhrRyxRQUEwQkEsT0FBT0M7UUFDMUNULE9BQU9DLGVBQWUzRixRQUFTa0csT0FBT0MsWUFBYSxDQUFFQyxNQUFPO1NBRTdEVixPQUFPQyxlQUFlM0YsUUFBUyxhQUFjLENBQUVvRyxPQUFPLEdBQU87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0d2RCxJLHVFQ0FIQyxTQUFXLENBQUMsRUFRWkMsZUFBaUI7Z0RBRXJCRDtTQUFTRSxHQUFLLFdBQ1YsSUFJSUMsY0FLQUMsZ0JBSUFDLGdCQVhBQyxhQUFjLEVBQ2RDLGNBQWdCLENBQUMsRUFFakJDLFFBQVUsQ0FBQyxFQUNYQyxhQUFlLENBQUMsRUFDaEJDLHNCQUF3QixDQUFDLEVBQ3pCQyxvQkFBcUIsRUFFckJDLFVBQVksQ0FBQyxFQUNiQyxjQUFnQixHQUNoQkMseUJBQTJCQyxPQUFPQyxVQUVsQ0Msa0JBQW1COzs7Ozs7OztBQVN2QjNFLEtBQUs0RSxtQkFBcUIsU0FBU0MsT0FDM0JBLGlCQUFpQkM7O0FBRWpCZixnQkFBa0JjLE9BQ1ZFLE1BQU1DLFdBQVdILFNBQVdJLFNBQVNKOztBQUU3Q2QsZ0JBQWtCLENBQUNjLE9BRTNCOzs7OztBQU1BN0UsS0FBS2tGLFdBQWEsV0FDZGxCLGFBQWMsQ0FDbEI7Ozs7QUFLQWhFLEtBQUttRixZQUFjLFdBQ2ZuQixhQUFjLENBQ2xCOzs7O0FBS0FoRSxLQUFLb0YsZ0JBQWtCLFdBQ25CVCxrQkFBbUIsQ0FDdkI7Ozs7QUFLQTNFLEtBQUtxRixpQkFBbUIsV0FDcEJWLGtCQUFtQixDQUN2Qjs7Ozs7OztBQVFBM0UsS0FBS3NGLFFBQVUsU0FBU0MsTUFDcEIxQixjQUFnQjBCOztBQUdoQixJQUFLLElBQUloSCxFQUFJLEVBQUdBLEVBQUlzRixjQUFjL0UsT0FBUVAsSUFDdEMsSUFBSyxJQUFJRCxFQUFJLEVBQUdBLEVBQUl1RixjQUFjLEdBQUcvRSxPQUFRUixJQUNwQzRGLFFBQVFMLGNBQWN0RixHQUFHRCxNQUMxQjRGLFFBQVFMLGNBQWN0RixHQUFHRCxJQUFNLEVBSS9DOzs7Ozs7O0FBUUEwQixLQUFLd0YsWUFBYyxTQUFTQyxTQUFVQyxNQUNsQ3hCLFFBQVF1QixVQUFZQyxJQUN4Qjs7Ozs7Ozs7O0FBVUExRixLQUFLMkYsdUJBQXlCLFNBQVNySCxFQUFHQyxFQUFHbUgsV0FDakJuRCxJQUFwQjRCLGFBQWE1RixLQUNiNEYsYUFBYTVGLEdBQUssQ0FBQyxHQUV2QjRGLGFBQWE1RixHQUFHRCxHQUFLb0gsSUFDekI7Ozs7Ozs7QUFRQTFGLEtBQUs0RiwwQkFBNEIsU0FBU3RILEVBQUdDLFFBQ2pCZ0UsSUFBcEI0QixhQUFhNUYsV0FDTjRGLGFBQWE1RixHQUFHRCxFQUUvQjs7OztBQUtBMEIsS0FBSzZGLDhCQUFnQyxXQUNqQzFCLGFBQWUsQ0FBQyxDQUNwQjs7Ozs7Ozs7O0FBVUFuRSxLQUFLOEYsd0JBQTBCLFNBQVN4SCxFQUFHQyxFQUFHd0gsd0JBQ1R4RCxJQUE3QjZCLHNCQUFzQjdGLEtBQ3RCNkYsc0JBQXNCN0YsR0FBSyxDQUFDLEdBRWhDNkYsc0JBQXNCN0YsR0FBR0QsR0FBS3lILGlCQUNsQzs7OztBQUtBL0YsS0FBS2dHLCtCQUFpQyxXQUNsQzVCLHNCQUF3QixDQUFDLENBQzdCOzs7Ozs7Ozs7QUFVQXBFLEtBQUtpRyw0QkFBOEIsU0FBU0MsWUFDeEMxQix5QkFBMkIwQixVQUMvQjs7Ozs7Ozs7QUFTQWxHLEtBQUttRyxxQkFBdUIsU0FBUzdILEVBQUdDLFFBQ1hnRSxJQUFyQjBCLGNBQWMxRixLQUNkMEYsY0FBYzFGLEdBQUssQ0FBQyxHQUV4QjBGLGNBQWMxRixHQUFHRCxHQUFLLENBQzFCOzs7Ozs7O0FBUUEwQixLQUFLb0csNEJBQThCLFNBQVM5SCxFQUFHQyxRQUNsQmdFLElBQXJCMEIsY0FBYzFGLFdBQ1AwRixjQUFjMUYsR0FBR0QsRUFFaEM7Ozs7QUFLQTBCLEtBQUtxRyxvQkFBc0IsV0FDdkJoQyxvQkFBcUIsQ0FDekI7Ozs7QUFLQXJFLEtBQUtzRyxxQkFBdUIsV0FDeEJqQyxvQkFBcUIsQ0FDekI7Ozs7QUFLQXJFLEtBQUt1RyxnQ0FBa0MsV0FDbkN0QyxjQUFnQixDQUFDLENBQ3JCOzs7Ozs7Ozs7Ozs7O0FBY0FqRSxLQUFLd0csU0FBVyxTQUFTQyxPQUFRQyxPQUFRQyxLQUFNQyxLQUFNQzs7QUFFakQsSUFBSUMsZ0JBQWtCLFNBQVN4RyxRQUN2QjBELFlBQ0E2QyxTQUFTdkcsUUFFVHlHLFlBQVcsV0FDUEYsU0FBU3ZHLE9BQ2IsR0FFUjsrQkFHQTtRQUF3QmlDLElBQXBCd0IsZ0JBQ0EsTUFBTSxJQUFJbEYsTUFBTTtrQkFHcEI7UUFBc0IwRCxJQUFsQnNCLGNBQ0EsTUFBTSxJQUFJaEYsTUFBTTtzQ0FJcEI7R0FBSTRILE9BQVMsR0FBS0MsT0FBUyxHQUFLQyxLQUFPLEdBQUtDLEtBQU8sR0FDbkRILE9BQVM1QyxjQUFjLEdBQUcvRSxPQUFPLEdBQUs0SCxPQUFTN0MsY0FBYy9FLE9BQU8sR0FDcEU2SCxLQUFPOUMsY0FBYyxHQUFHL0UsT0FBTyxHQUFLOEgsS0FBTy9DLGNBQWMvRSxPQUFPLEVBQzVELE1BQU0sSUFBSUQsTUFBTTttQ0FJcEI7R0FBSTRILFNBQVNFLE1BQVFELFNBQVNFLEtBQTlCLENBUUE7O0FBRkEsSUFBSUksUUFBVW5ELGNBQWMrQyxNQUFNRCxNQUM5Qk0sY0FBZSxFQUNWeEgsRUFBSSxFQUFHQSxFQUFJc0UsZ0JBQWdCakYsT0FBUVcsSUFDeEMsR0FBSXVILFVBQVlqRCxnQkFBZ0J0RSxHQUFJLENBQ2hDd0gsY0FBZSxFQUNmLEtBQ0osQ0FHSixJQUFxQixJQUFqQkEsYUFBSjs7QUFNQSxJQUFJQyxTQUFXLElBQUlDLHlCQUFBQSxRQUNuQkQsU0FBU0UsU0FBVyxJQUFJOUosZUFBSixFQUFTLFNBQVMrSixNQUFPQyxPQUN6QyxPQUFPRCxNQUFNRSxvQkFBc0JELE1BQU1DLG1CQUM3QyxJQUNBTCxTQUFTTSxtQkFBb0IsRUFDN0JOLFNBQVNPLFNBQVcsQ0FBQyxFQUNyQlAsU0FBU1QsT0FBU0EsT0FDbEJTLFNBQVNSLE9BQVNBLE9BQ2xCUSxTQUFTUCxLQUFPQSxLQUNoQk8sU0FBU04sS0FBT0EsS0FDaEJNLFNBQVNMLFNBQVdDLGdCQUVwQkksU0FBU0UsU0FBU2hJLEtBQUtzSSxpQkFBaUJSLFNBQVVBLFNBQVNULE9BQ3ZEUyxTQUFTUixPQUFRLEtBelJMLElBMlJoQixJQUFJaUIsV0FBYWhFLGlCQUdqQixPQUZBVyxVQUFVcUQsWUFBY1QsU0FDeEIzQyxjQUFjbkYsS0FBS3VJLFlBQ1pBLFVBckJQLENBRkliLGdCQUFnQixLQWJwQixNQUZJQSxnQkFBZ0IsR0F1Q3hCOzs7Ozs7OztBQVNBOUcsS0FBSzRILFdBQWEsU0FBU0QsWUFDdkIsT0FBSUEsY0FBY3JELG1CQUNQQSxVQUFVcUQsYUFFVixFQUdmOzs7Ozs7O0FBUUEzSCxLQUFLNkgsVUFBWSxXQUNiLEdBQTZCLElBQXpCdEQsY0FBY3pGLGFBQWtDeUQsSUFBbEJzQixvQkFBbUR0QixJQUFwQndCLGdCQUdqRSxJQUFLRCxnQkFBa0IsRUFBR0EsZ0JBQWtCVSx5QkFBMEJWLGtCQUFtQixDQUNyRixHQUE2QixJQUF6QlMsY0FBY3pGLE9BQ2QsT0FHQWtGOztBQUVBRixnQkFBa0IsR0FHdEIsSUFBSTZELFdBQWFwRCxjQUFjLEdBQzNCMkMsU0FBVzVDLFVBQVVxRCxZQUN6QixRQUF1QixJQUFaVDs7QUFPWCxHQUFpQyxJQUE3QkEsU0FBU0UsU0FBUzNGLE9BQXRCLENBT0EsSUFBSXFHLFdBQWFaLFNBQVNFLFNBQVM3SDt1REFHbkM7R0FBSTJILFNBQVNQLE9BQVNtQixXQUFXeEosR0FBSzRJLFNBQVNOLE9BQVNrQixXQUFXdkosRUFnQm5FdUosV0FBV0MsS0E5V0gsRUFnWEpELFdBQVd2SixFQUFJLEdBQ2Z5SixrQkFBa0JkLFNBQVVZLFdBQ3hCLEdBQUksRUE1V0EsRUE0V21CRyxZQUFZSCxXQUFXeEosRUFBR3dKLFdBQVd2SixFQUFFLElBRWxFdUosV0FBV3hKLEVBQUl1RixjQUFjLEdBQUcvRSxPQUFPLEdBQ3ZDa0osa0JBQWtCZCxTQUFVWSxXQUN4QixFQUFHLEVBaFhDLEVBZ1hrQkcsWUFBWUgsV0FBV3hKLEVBQUUsRUFBR3dKLFdBQVd2SixJQUVqRXVKLFdBQVd2SixFQUFJc0YsY0FBYy9FLE9BQU8sR0FDcENrSixrQkFBa0JkLFNBQVVZLFdBQ3hCLEVBQUcsRUFwWEMsRUFvWGtCRyxZQUFZSCxXQUFXeEosRUFBR3dKLFdBQVd2SixFQUFFLElBRWpFdUosV0FBV3hKLEVBQUksR0FDZjBKLGtCQUFrQmQsU0FBVVksWUFDdkIsRUFBRyxFQXhYQSxFQXdYbUJHLFlBQVlILFdBQVd4SixFQUFFLEVBQUd3SixXQUFXdkosSUFFbEVvRyxtQkFDSW1ELFdBQVd4SixFQUFJLEdBQUt3SixXQUFXdkosRUFBSSxJQUUvQjhGLG9CQUNDNkQsZUFBZXJFLGNBQWVFLGdCQUFpQitELFdBQVd4SixFQUFHd0osV0FBV3ZKLEVBQUUsRUFBR3VKLGFBQzlFSSxlQUFlckUsY0FBZUUsZ0JBQWlCK0QsV0FBV3hKLEVBQUUsRUFBR3dKLFdBQVd2SixFQUFHdUosY0FFN0VFLGtCQUFrQmQsU0FBVVksWUFDdkIsR0FBSSxFQWpZVCxJQWlZNEJHLFlBQVlILFdBQVd4SixFQUFFLEVBQUd3SixXQUFXdkosRUFBRSxJQUd6RXVKLFdBQVd4SixFQUFJdUYsY0FBYyxHQUFHL0UsT0FBTyxHQUFLZ0osV0FBV3ZKLEVBQUlzRixjQUFjL0UsT0FBTyxJQUU1RXVGLG9CQUNDNkQsZUFBZXJFLGNBQWVFLGdCQUFpQitELFdBQVd4SixFQUFHd0osV0FBV3ZKLEVBQUUsRUFBR3VKLGFBQzlFSSxlQUFlckUsY0FBZUUsZ0JBQWlCK0QsV0FBV3hKLEVBQUUsRUFBR3dKLFdBQVd2SixFQUFHdUosY0FFN0VFLGtCQUFrQmQsU0FBVVksV0FDeEIsRUFBRyxFQTNZUCxJQTJZMEJHLFlBQVlILFdBQVd4SixFQUFFLEVBQUd3SixXQUFXdkosRUFBRSxJQUd2RXVKLFdBQVd4SixFQUFJdUYsY0FBYyxHQUFHL0UsT0FBTyxHQUFLZ0osV0FBV3ZKLEVBQUksSUFFdkQ4RixvQkFDQzZELGVBQWVyRSxjQUFlRSxnQkFBaUIrRCxXQUFXeEosRUFBR3dKLFdBQVd2SixFQUFFLEVBQUd1SixhQUM5RUksZUFBZXJFLGNBQWVFLGdCQUFpQitELFdBQVd4SixFQUFFLEVBQUd3SixXQUFXdkosRUFBR3VKLGNBRTdFRSxrQkFBa0JkLFNBQVVZLFdBQ3hCLEdBQUksRUFyWlIsSUFxWjJCRyxZQUFZSCxXQUFXeEosRUFBRSxFQUFHd0osV0FBV3ZKLEVBQUUsSUFHeEV1SixXQUFXeEosRUFBSSxHQUFLd0osV0FBV3ZKLEVBQUlzRixjQUFjL0UsT0FBTyxJQUVwRHVGLG9CQUNDNkQsZUFBZXJFLGNBQWVFLGdCQUFpQitELFdBQVd4SixFQUFHd0osV0FBV3ZKLEVBQUUsRUFBR3VKLGFBQzlFSSxlQUFlckUsY0FBZUUsZ0JBQWlCK0QsV0FBV3hKLEVBQUUsRUFBR3dKLFdBQVd2SixFQUFHdUosY0FFN0VFLGtCQUFrQmQsU0FBVVksWUFDdkIsRUFBRyxFQS9aUixJQStaMkJHLFlBQVlILFdBQVd4SixFQUFFLEVBQUd3SixXQUFXdkosRUFBRSxTQXhFaEYsQ0FDSSxJQUFJNEosS0FBTyxHQUNYQSxLQUFLL0ksS0FBSyxDQUFDZCxFQUFHd0osV0FBV3hKLEVBQUdDLEVBQUd1SixXQUFXdkosSUFFMUMsSUFEQSxJQUFJcUMsT0FBU2tILFdBQVdsSCxPQUNULE1BQVJBLFFBQ0h1SCxLQUFLL0ksS0FBSyxDQUFDZCxFQUFHc0MsT0FBT3RDLEVBQUdDLEVBQUVxQyxPQUFPckMsSUFDakNxQyxPQUFTQSxPQUFPQSxPQUVwQnVILEtBQUtsSSxVQUNMLElBQUltSSxHQUFLRCxLQUNUakIsU0FBU0wsU0FBU3VCLFdBQ1g5RCxVQUFVcUQsWUFDakJwRCxjQUFjOEQsT0FFbEIsQ0FuQkEsTUFKSW5CLFNBQVNMLFNBQVMsYUFDWHZDLFVBQVVxRCxZQUNqQnBELGNBQWM4RDs7QUFSZDlELGNBQWM4RCxPQTRGdEIsQ0FDSjs7QUFHQSxJQUFJTCxrQkFBb0IsU0FBU2QsU0FBVVksV0FBWXhKLEVBQUdDLEVBQUdtSCxNQUN6RCxJQUFJNEMsb0JBQXNCUixXQUFXeEosRUFBRUEsRUFDbkNpSyxvQkFBc0JULFdBQVd2SixFQUFFQSxFQUV2QyxTQUE0Q2dFLElBQXZDMEIsY0FBY3NFLDJCQUM4Q2hHLElBQTVEMEIsY0FBY3NFLHFCQUFxQkQsdUJBQ3BDSixlQUFlckUsY0FBZUUsZ0JBQWlCdUUsb0JBQXFCQyxvQkFBcUJULFlBQWEsQ0FDdEcsSUFBSVUsS0FBT2QsaUJBQWlCUixTQUFVb0Isb0JBQ2xDQyxvQkFBcUJULFdBQVlwQyxXQUVuQm5ELElBQWRpRyxLQUFLVCxNQUNMUyxLQUFLVCxLQXpiSCxFQTBiRmIsU0FBU0UsU0FBU2hJLEtBQUtvSixPQUNoQlYsV0FBV1csVUFBWS9DLEtBQU84QyxLQUFLQyxZQUMxQ0QsS0FBS0MsVUFBWVgsV0FBV1csVUFBWS9DLEtBQ3hDOEMsS0FBSzVILE9BQVNrSCxXQUNkWixTQUFTRSxTQUFTbEosV0FBV3NLLE1BRXJDLENBQ0osRUFHSU4sZUFBaUIsU0FBU3JFLGNBQWVFLGdCQUFpQnpGLEVBQUdDLEVBQUdtSyxZQUNoRSxJQUFJQyxxQkFBdUJ2RSxzQkFBc0I3RixJQUFNNkYsc0JBQXNCN0YsR0FBR0QsR0FDaEYsR0FBSXFLLHFCQUFzQixDQUN0QixJQUFJQyxVQUFZQyxtQkFBbUJILFdBQVdwSyxFQUFJQSxFQUFHb0ssV0FBV25LLEVBQUlBLEdBT3BFLElBTndCLFdBQ3BCLElBQUssSUFBSWtCLEVBQUksRUFBR0EsRUFBSWtKLHFCQUFxQjdKLE9BQVFXLElBQzdDLEdBQUlrSixxQkFBcUJsSixLQUFPbUosVUFBVyxPQUFPLEVBRXRELE9BQU8sQ0FDWCxDQUNLRSxHQUFxQixPQUFPLENBQ3JDLENBQ0EsSUFBSyxJQUFJckosRUFBSSxFQUFHQSxFQUFJc0UsZ0JBQWdCakYsT0FBUVcsSUFDeEMsR0FBSW9FLGNBQWN0RixHQUFHRCxLQUFPeUYsZ0JBQWdCdEUsR0FDeEMsT0FBTyxFQUlmLE9BQU8sQ0FDWCxFQU9Jb0osbUJBQXFCLFNBQVVFLE1BQU9DLE9BQ3RDLEdBQWMsSUFBVkQsUUFBMEIsSUFBWEMsTUFBYyxPQUFPdEYsU0FBU3VGLElBQzVDLEdBQWMsSUFBVkYsUUFBMEIsSUFBWEMsTUFBYyxPQUFPdEYsU0FBU3dGLFVBQ2pELEdBQWMsSUFBVkgsT0FBeUIsSUFBVkMsTUFBYSxPQUFPdEYsU0FBU3lGLE1BQ2hELEdBQWMsSUFBVkosT0FBeUIsSUFBVkMsTUFBYSxPQUFPdEYsU0FBUzBGLGFBQ2hELEdBQWMsSUFBVkwsT0FBeUIsSUFBVkMsTUFBYSxPQUFPdEYsU0FBUzJGLE9BQ2hELElBQWUsSUFBWE4sT0FBMEIsSUFBVkMsTUFBYSxPQUFPdEYsU0FBUzRGLFlBQ2pELElBQWUsSUFBWFAsT0FBMEIsSUFBVkMsTUFBYSxPQUFPdEYsU0FBUzZGLEtBQ2pELElBQWUsSUFBWFIsUUFBMkIsSUFBWEMsTUFBYyxPQUFPdEYsU0FBUzhGLFNBQ3ZELE1BQU0sSUFBSTNLLE1BQU0sb0NBQXNDa0ssTUFBUSxLQUFPQyxNQUN6RSxFQUVJZixZQUFjLFNBQVMzSixFQUFHQyxHQUMxQixPQUFRNEYsYUFBYTVGLElBQU00RixhQUFhNUYsR0FBR0QsSUFBTzRGLFFBQVFMLGNBQWN0RixHQUFHRCxHQUMvRSxFQUVJb0osaUJBQW1CLFNBQVNSLFNBQVU1SSxFQUFHQyxFQUFHcUMsT0FBUThFLE1BQ3BELFFBQTZCbkQsSUFBekIyRSxTQUFTTyxTQUFTbEosSUFDbEIsUUFBZ0NnRSxJQUE1QjJFLFNBQVNPLFNBQVNsSixHQUFHRCxHQUNyQixPQUFPNEksU0FBU08sU0FBU2xKLEdBQUdELFFBR2hDNEksU0FBU08sU0FBU2xKLEdBQUssQ0FBQyxFQUU1QixJQUFJa0wsdUJBQXlCQyxZQUFZcEwsRUFBR0MsRUFBRzJJLFNBQVNQLEtBQU1PLFNBQVNOLE1BQ3ZFLEdBQWEsT0FBVGhHLE9BQ0EsSUFBSTZILFVBQVk3SCxPQUFPNkgsVUFBWS9DLFVBRW5DK0MsVUFBWSxFQUVoQixJQUFJRCxLQUFPLElBQUltQixxQkFBQUEsUUFBSy9JLE9BQU90QyxFQUFFQyxFQUFFa0ssVUFBVWdCLHdCQUV6QyxPQURBdkMsU0FBU08sU0FBU2xKLEdBQUdELEdBQUtrSyxLQUNuQkEsSUFDWCxFQUVJa0IsWUFBYyxTQUFTRSxHQUFHQyxHQUFHQyxHQUFHQzs7QUFHNUIsSUFTSUMsR0FDQUMsR0FaUixPQUFJdEYsa0JBRUlxRixHQUFLM0wsS0FBSzZMLElBQUlOLEdBQUtFLE1BQ25CRyxHQUFLNUwsS0FBSzZMLElBQUlMLEdBQUtFLEtBL2ZYLElBaWdCZUMsR0FBS0MsR0FqZ0JwQixJQW1nQmVBLEdBQUtELElBSTVCQSxHQUFLM0wsS0FBSzZMLElBQUlOLEdBQUtFLE1BQ25CRyxHQUFLNUwsS0FBSzZMLElBQUlMLEdBQUtFLElBRy9CO1VBQ0o7RUFFQXJHLFNBQVN1RixJQUFNLE1BQ2Z2RixTQUFTd0YsVUFBWSxZQUNyQnhGLFNBQVN5RixNQUFRLFFBQ2pCekYsU0FBUzBGLGFBQWUsZUFDeEIxRixTQUFTMkYsT0FBUyxTQUNsQjNGLFNBQVM0RixZQUFjLGNBQ3ZCNUYsU0FBUzZGLEtBQU8sT0FDaEI3RixTQUFTOEYsU0FBVyxVIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZWFzeXN0YXJqcy8uL25vZGVfbW9kdWxlcy9oZWFwL2luZGV4LmpzIiwid2VicGFjazovL2Vhc3lzdGFyanMvLi9ub2RlX21vZHVsZXMvaGVhcC9saWIvaGVhcC5qcyIsIndlYnBhY2s6Ly9lYXN5c3RhcmpzL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2Vhc3lzdGFyanMvd2VicGFjay9ydW50aW1lL2NvbXBhdCBnZXQgZGVmYXVsdCBleHBvcnQiLCJ3ZWJwYWNrOi8vZWFzeXN0YXJqcy93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vZWFzeXN0YXJqcy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2Vhc3lzdGFyanMvd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly9lYXN5c3RhcmpzLy4vc3JjL25vZGUuanMiLCJ3ZWJwYWNrOi8vZWFzeXN0YXJqcy8uL3NyYy9lYXN5c3Rhci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2hlYXAnKTtcbiIsIi8vIEdlbmVyYXRlZCBieSBDb2ZmZWVTY3JpcHQgMS44LjBcbihmdW5jdGlvbigpIHtcbiAgdmFyIEhlYXAsIGRlZmF1bHRDbXAsIGZsb29yLCBoZWFwaWZ5LCBoZWFwcG9wLCBoZWFwcHVzaCwgaGVhcHB1c2hwb3AsIGhlYXByZXBsYWNlLCBpbnNvcnQsIG1pbiwgbmxhcmdlc3QsIG5zbWFsbGVzdCwgdXBkYXRlSXRlbSwgX3NpZnRkb3duLCBfc2lmdHVwO1xuXG4gIGZsb29yID0gTWF0aC5mbG9vciwgbWluID0gTWF0aC5taW47XG5cblxuICAvKlxuICBEZWZhdWx0IGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gYmUgdXNlZFxuICAgKi9cblxuICBkZWZhdWx0Q21wID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh4IDwgeSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoeCA+IHkpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcblxuXG4gIC8qXG4gIEluc2VydCBpdGVtIHggaW4gbGlzdCBhLCBhbmQga2VlcCBpdCBzb3J0ZWQgYXNzdW1pbmcgYSBpcyBzb3J0ZWQuXG4gIFxuICBJZiB4IGlzIGFscmVhZHkgaW4gYSwgaW5zZXJ0IGl0IHRvIHRoZSByaWdodCBvZiB0aGUgcmlnaHRtb3N0IHguXG4gIFxuICBPcHRpb25hbCBhcmdzIGxvIChkZWZhdWx0IDApIGFuZCBoaSAoZGVmYXVsdCBhLmxlbmd0aCkgYm91bmQgdGhlIHNsaWNlXG4gIG9mIGEgdG8gYmUgc2VhcmNoZWQuXG4gICAqL1xuXG4gIGluc29ydCA9IGZ1bmN0aW9uKGEsIHgsIGxvLCBoaSwgY21wKSB7XG4gICAgdmFyIG1pZDtcbiAgICBpZiAobG8gPT0gbnVsbCkge1xuICAgICAgbG8gPSAwO1xuICAgIH1cbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIGlmIChsbyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbG8gbXVzdCBiZSBub24tbmVnYXRpdmUnKTtcbiAgICB9XG4gICAgaWYgKGhpID09IG51bGwpIHtcbiAgICAgIGhpID0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgICBtaWQgPSBmbG9vcigobG8gKyBoaSkgLyAyKTtcbiAgICAgIGlmIChjbXAoeCwgYVttaWRdKSA8IDApIHtcbiAgICAgICAgaGkgPSBtaWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsbyA9IG1pZCArIDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAoW10uc3BsaWNlLmFwcGx5KGEsIFtsbywgbG8gLSBsb10uY29uY2F0KHgpKSwgeCk7XG4gIH07XG5cblxuICAvKlxuICBQdXNoIGl0ZW0gb250byBoZWFwLCBtYWludGFpbmluZyB0aGUgaGVhcCBpbnZhcmlhbnQuXG4gICAqL1xuXG4gIGhlYXBwdXNoID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgYXJyYXkucHVzaChpdGVtKTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCAwLCBhcnJheS5sZW5ndGggLSAxLCBjbXApO1xuICB9O1xuXG5cbiAgLypcbiAgUG9wIHRoZSBzbWFsbGVzdCBpdGVtIG9mZiB0aGUgaGVhcCwgbWFpbnRhaW5pbmcgdGhlIGhlYXAgaW52YXJpYW50LlxuICAgKi9cblxuICBoZWFwcG9wID0gZnVuY3Rpb24oYXJyYXksIGNtcCkge1xuICAgIHZhciBsYXN0ZWx0LCByZXR1cm5pdGVtO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgbGFzdGVsdCA9IGFycmF5LnBvcCgpO1xuICAgIGlmIChhcnJheS5sZW5ndGgpIHtcbiAgICAgIHJldHVybml0ZW0gPSBhcnJheVswXTtcbiAgICAgIGFycmF5WzBdID0gbGFzdGVsdDtcbiAgICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybml0ZW0gPSBsYXN0ZWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0dXJuaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFBvcCBhbmQgcmV0dXJuIHRoZSBjdXJyZW50IHNtYWxsZXN0IHZhbHVlLCBhbmQgYWRkIHRoZSBuZXcgaXRlbS5cbiAgXG4gIFRoaXMgaXMgbW9yZSBlZmZpY2llbnQgdGhhbiBoZWFwcG9wKCkgZm9sbG93ZWQgYnkgaGVhcHB1c2goKSwgYW5kIGNhbiBiZVxuICBtb3JlIGFwcHJvcHJpYXRlIHdoZW4gdXNpbmcgYSBmaXhlZCBzaXplIGhlYXAuIE5vdGUgdGhhdCB0aGUgdmFsdWVcbiAgcmV0dXJuZWQgbWF5IGJlIGxhcmdlciB0aGFuIGl0ZW0hIFRoYXQgY29uc3RyYWlucyByZWFzb25hYmxlIHVzZSBvZlxuICB0aGlzIHJvdXRpbmUgdW5sZXNzIHdyaXR0ZW4gYXMgcGFydCBvZiBhIGNvbmRpdGlvbmFsIHJlcGxhY2VtZW50OlxuICAgICAgaWYgaXRlbSA+IGFycmF5WzBdXG4gICAgICAgIGl0ZW0gPSBoZWFwcmVwbGFjZShhcnJheSwgaXRlbSlcbiAgICovXG5cbiAgaGVhcHJlcGxhY2UgPSBmdW5jdGlvbihhcnJheSwgaXRlbSwgY21wKSB7XG4gICAgdmFyIHJldHVybml0ZW07XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICByZXR1cm5pdGVtID0gYXJyYXlbMF07XG4gICAgYXJyYXlbMF0gPSBpdGVtO1xuICAgIF9zaWZ0dXAoYXJyYXksIDAsIGNtcCk7XG4gICAgcmV0dXJuIHJldHVybml0ZW07XG4gIH07XG5cblxuICAvKlxuICBGYXN0IHZlcnNpb24gb2YgYSBoZWFwcHVzaCBmb2xsb3dlZCBieSBhIGhlYXBwb3AuXG4gICAqL1xuXG4gIGhlYXBwdXNocG9wID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBfcmVmO1xuICAgIGlmIChjbXAgPT0gbnVsbCkge1xuICAgICAgY21wID0gZGVmYXVsdENtcDtcbiAgICB9XG4gICAgaWYgKGFycmF5Lmxlbmd0aCAmJiBjbXAoYXJyYXlbMF0sIGl0ZW0pIDwgMCkge1xuICAgICAgX3JlZiA9IFthcnJheVswXSwgaXRlbV0sIGl0ZW0gPSBfcmVmWzBdLCBhcnJheVswXSA9IF9yZWZbMV07XG4gICAgICBfc2lmdHVwKGFycmF5LCAwLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbiAgfTtcblxuXG4gIC8qXG4gIFRyYW5zZm9ybSBsaXN0IGludG8gYSBoZWFwLCBpbi1wbGFjZSwgaW4gTyhhcnJheS5sZW5ndGgpIHRpbWUuXG4gICAqL1xuXG4gIGhlYXBpZnkgPSBmdW5jdGlvbihhcnJheSwgY21wKSB7XG4gICAgdmFyIGksIF9pLCBfaiwgX2xlbiwgX3JlZiwgX3JlZjEsIF9yZXN1bHRzLCBfcmVzdWx0czE7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBfcmVmMSA9IChmdW5jdGlvbigpIHtcbiAgICAgIF9yZXN1bHRzMSA9IFtdO1xuICAgICAgZm9yICh2YXIgX2ogPSAwLCBfcmVmID0gZmxvb3IoYXJyYXkubGVuZ3RoIC8gMik7IDAgPD0gX3JlZiA/IF9qIDwgX3JlZiA6IF9qID4gX3JlZjsgMCA8PSBfcmVmID8gX2orKyA6IF9qLS0peyBfcmVzdWx0czEucHVzaChfaik7IH1cbiAgICAgIHJldHVybiBfcmVzdWx0czE7XG4gICAgfSkuYXBwbHkodGhpcykucmV2ZXJzZSgpO1xuICAgIF9yZXN1bHRzID0gW107XG4gICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmMS5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgaSA9IF9yZWYxW19pXTtcbiAgICAgIF9yZXN1bHRzLnB1c2goX3NpZnR1cChhcnJheSwgaSwgY21wKSk7XG4gICAgfVxuICAgIHJldHVybiBfcmVzdWx0cztcbiAgfTtcblxuXG4gIC8qXG4gIFVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgdGhlIGdpdmVuIGl0ZW0gaW4gdGhlIGhlYXAuXG4gIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBldmVyeSB0aW1lIHRoZSBpdGVtIGlzIGJlaW5nIG1vZGlmaWVkLlxuICAgKi9cblxuICB1cGRhdGVJdGVtID0gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGNtcCkge1xuICAgIHZhciBwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBwb3MgPSBhcnJheS5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChwb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9zaWZ0ZG93bihhcnJheSwgMCwgcG9zLCBjbXApO1xuICAgIHJldHVybiBfc2lmdHVwKGFycmF5LCBwb3MsIGNtcCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIGxhcmdlc3QgZWxlbWVudHMgaW4gYSBkYXRhc2V0LlxuICAgKi9cblxuICBubGFyZ2VzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBjbXApIHtcbiAgICB2YXIgZWxlbSwgcmVzdWx0LCBfaSwgX2xlbiwgX3JlZjtcbiAgICBpZiAoY21wID09IG51bGwpIHtcbiAgICAgIGNtcCA9IGRlZmF1bHRDbXA7XG4gICAgfVxuICAgIHJlc3VsdCA9IGFycmF5LnNsaWNlKDAsIG4pO1xuICAgIGlmICghcmVzdWx0Lmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgaGVhcGlmeShyZXN1bHQsIGNtcCk7XG4gICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgIGZvciAoX2kgPSAwLCBfbGVuID0gX3JlZi5sZW5ndGg7IF9pIDwgX2xlbjsgX2krKykge1xuICAgICAgZWxlbSA9IF9yZWZbX2ldO1xuICAgICAgaGVhcHB1c2hwb3AocmVzdWx0LCBlbGVtLCBjbXApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnNvcnQoY21wKS5yZXZlcnNlKCk7XG4gIH07XG5cblxuICAvKlxuICBGaW5kIHRoZSBuIHNtYWxsZXN0IGVsZW1lbnRzIGluIGEgZGF0YXNldC5cbiAgICovXG5cbiAgbnNtYWxsZXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGNtcCkge1xuICAgIHZhciBlbGVtLCBpLCBsb3MsIHJlc3VsdCwgX2ksIF9qLCBfbGVuLCBfcmVmLCBfcmVmMSwgX3Jlc3VsdHM7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBpZiAobiAqIDEwIDw9IGFycmF5Lmxlbmd0aCkge1xuICAgICAgcmVzdWx0ID0gYXJyYXkuc2xpY2UoMCwgbikuc29ydChjbXApO1xuICAgICAgaWYgKCFyZXN1bHQubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsb3MgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgX3JlZiA9IGFycmF5LnNsaWNlKG4pO1xuICAgICAgZm9yIChfaSA9IDAsIF9sZW4gPSBfcmVmLmxlbmd0aDsgX2kgPCBfbGVuOyBfaSsrKSB7XG4gICAgICAgIGVsZW0gPSBfcmVmW19pXTtcbiAgICAgICAgaWYgKGNtcChlbGVtLCBsb3MpIDwgMCkge1xuICAgICAgICAgIGluc29ydChyZXN1bHQsIGVsZW0sIDAsIG51bGwsIGNtcCk7XG4gICAgICAgICAgcmVzdWx0LnBvcCgpO1xuICAgICAgICAgIGxvcyA9IHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGhlYXBpZnkoYXJyYXksIGNtcCk7XG4gICAgX3Jlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGkgPSBfaiA9IDAsIF9yZWYxID0gbWluKG4sIGFycmF5Lmxlbmd0aCk7IDAgPD0gX3JlZjEgPyBfaiA8IF9yZWYxIDogX2ogPiBfcmVmMTsgaSA9IDAgPD0gX3JlZjEgPyArK19qIDogLS1faikge1xuICAgICAgX3Jlc3VsdHMucHVzaChoZWFwcG9wKGFycmF5LCBjbXApKTtcbiAgICB9XG4gICAgcmV0dXJuIF9yZXN1bHRzO1xuICB9O1xuXG4gIF9zaWZ0ZG93biA9IGZ1bmN0aW9uKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApIHtcbiAgICB2YXIgbmV3aXRlbSwgcGFyZW50LCBwYXJlbnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBuZXdpdGVtID0gYXJyYXlbcG9zXTtcbiAgICB3aGlsZSAocG9zID4gc3RhcnRwb3MpIHtcbiAgICAgIHBhcmVudHBvcyA9IChwb3MgLSAxKSA+PiAxO1xuICAgICAgcGFyZW50ID0gYXJyYXlbcGFyZW50cG9zXTtcbiAgICAgIGlmIChjbXAobmV3aXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgICAgYXJyYXlbcG9zXSA9IHBhcmVudDtcbiAgICAgICAgcG9zID0gcGFyZW50cG9zO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbcG9zXSA9IG5ld2l0ZW07XG4gIH07XG5cbiAgX3NpZnR1cCA9IGZ1bmN0aW9uKGFycmF5LCBwb3MsIGNtcCkge1xuICAgIHZhciBjaGlsZHBvcywgZW5kcG9zLCBuZXdpdGVtLCByaWdodHBvcywgc3RhcnRwb3M7XG4gICAgaWYgKGNtcCA9PSBudWxsKSB7XG4gICAgICBjbXAgPSBkZWZhdWx0Q21wO1xuICAgIH1cbiAgICBlbmRwb3MgPSBhcnJheS5sZW5ndGg7XG4gICAgc3RhcnRwb3MgPSBwb3M7XG4gICAgbmV3aXRlbSA9IGFycmF5W3Bvc107XG4gICAgY2hpbGRwb3MgPSAyICogcG9zICsgMTtcbiAgICB3aGlsZSAoY2hpbGRwb3MgPCBlbmRwb3MpIHtcbiAgICAgIHJpZ2h0cG9zID0gY2hpbGRwb3MgKyAxO1xuICAgICAgaWYgKHJpZ2h0cG9zIDwgZW5kcG9zICYmICEoY21wKGFycmF5W2NoaWxkcG9zXSwgYXJyYXlbcmlnaHRwb3NdKSA8IDApKSB7XG4gICAgICAgIGNoaWxkcG9zID0gcmlnaHRwb3M7XG4gICAgICB9XG4gICAgICBhcnJheVtwb3NdID0gYXJyYXlbY2hpbGRwb3NdO1xuICAgICAgcG9zID0gY2hpbGRwb3M7XG4gICAgICBjaGlsZHBvcyA9IDIgKiBwb3MgKyAxO1xuICAgIH1cbiAgICBhcnJheVtwb3NdID0gbmV3aXRlbTtcbiAgICByZXR1cm4gX3NpZnRkb3duKGFycmF5LCBzdGFydHBvcywgcG9zLCBjbXApO1xuICB9O1xuXG4gIEhlYXAgPSAoZnVuY3Rpb24oKSB7XG4gICAgSGVhcC5wdXNoID0gaGVhcHB1c2g7XG5cbiAgICBIZWFwLnBvcCA9IGhlYXBwb3A7XG5cbiAgICBIZWFwLnJlcGxhY2UgPSBoZWFwcmVwbGFjZTtcblxuICAgIEhlYXAucHVzaHBvcCA9IGhlYXBwdXNocG9wO1xuXG4gICAgSGVhcC5oZWFwaWZ5ID0gaGVhcGlmeTtcblxuICAgIEhlYXAudXBkYXRlSXRlbSA9IHVwZGF0ZUl0ZW07XG5cbiAgICBIZWFwLm5sYXJnZXN0ID0gbmxhcmdlc3Q7XG5cbiAgICBIZWFwLm5zbWFsbGVzdCA9IG5zbWFsbGVzdDtcblxuICAgIGZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gICAgICB0aGlzLmNtcCA9IGNtcCAhPSBudWxsID8gY21wIDogZGVmYXVsdENtcDtcbiAgICAgIHRoaXMubm9kZXMgPSBbXTtcbiAgICB9XG5cbiAgICBIZWFwLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXBwdXNoKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gaGVhcHBvcCh0aGlzLm5vZGVzLCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzWzBdO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5jb250YWlucyA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmluZGV4T2YoeCkgIT09IC0xO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24oeCkge1xuICAgICAgcmV0dXJuIGhlYXByZXBsYWNlKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUucHVzaHBvcCA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiBoZWFwcHVzaHBvcCh0aGlzLm5vZGVzLCB4LCB0aGlzLmNtcCk7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmhlYXBpZnkgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBoZWFwaWZ5KHRoaXMubm9kZXMsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUudXBkYXRlSXRlbSA9IGZ1bmN0aW9uKHgpIHtcbiAgICAgIHJldHVybiB1cGRhdGVJdGVtKHRoaXMubm9kZXMsIHgsIHRoaXMuY21wKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzID0gW107XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLmVtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5sZW5ndGggPT09IDA7XG4gICAgfTtcblxuICAgIEhlYXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVzLmxlbmd0aDtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBoZWFwO1xuICAgICAgaGVhcCA9IG5ldyBIZWFwKCk7XG4gICAgICBoZWFwLm5vZGVzID0gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICAgIHJldHVybiBoZWFwO1xuICAgIH07XG5cbiAgICBIZWFwLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2Rlcy5zbGljZSgwKTtcbiAgICB9O1xuXG4gICAgSGVhcC5wcm90b3R5cGUuaW5zZXJ0ID0gSGVhcC5wcm90b3R5cGUucHVzaDtcblxuICAgIEhlYXAucHJvdG90eXBlLnRvcCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5mcm9udCA9IEhlYXAucHJvdG90eXBlLnBlZWs7XG5cbiAgICBIZWFwLnByb3RvdHlwZS5oYXMgPSBIZWFwLnByb3RvdHlwZS5jb250YWlucztcblxuICAgIEhlYXAucHJvdG90eXBlLmNvcHkgPSBIZWFwLnByb3RvdHlwZS5jbG9uZTtcblxuICAgIHJldHVybiBIZWFwO1xuXG4gIH0pKCk7XG5cbiAgKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICByZXR1cm4gZGVmaW5lKFtdLCBmYWN0b3J5KTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcm9vdC5IZWFwID0gZmFjdG9yeSgpO1xuICAgIH1cbiAgfSkodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIEhlYXA7XG4gIH0pO1xuXG59KS5jYWxsKHRoaXMpO1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdCgpID0+IChtb2R1bGVbJ2RlZmF1bHQnXSkgOlxuXHRcdCgpID0+IChtb2R1bGUpO1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsIi8qKlxyXG4qIEEgc2ltcGxlIE5vZGUgdGhhdCByZXByZXNlbnRzIGEgc2luZ2xlIHRpbGUgb24gdGhlIGdyaWQuXHJcbiogQHBhcmFtIHtPYmplY3R9IHBhcmVudCBUaGUgcGFyZW50IG5vZGUuXHJcbiogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggcG9zaXRpb24gb24gdGhlIGdyaWQuXHJcbiogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgcG9zaXRpb24gb24gdGhlIGdyaWQuXHJcbiogQHBhcmFtIHtOdW1iZXJ9IGNvc3RTb0ZhciBIb3cgZmFyIHRoaXMgbm9kZSBpcyBpbiBtb3Zlcypjb3N0IGZyb20gdGhlIHN0YXJ0LlxyXG4qIEBwYXJhbSB7TnVtYmVyfSBzaW1wbGVEaXN0YW5jZVRvVGFyZ2V0IE1hbmhhdHRlbiBkaXN0YW5jZSB0byB0aGUgZW5kIHBvaW50LlxyXG4qKi9cclxuZXhwb3J0IGNsYXNzIE5vZGUge1xyXG4gICAgY29uc3RydWN0b3IocGFyZW50LCB4LCB5LCBjb3N0U29GYXIsIHNpbXBsZURpc3RhbmNlVG9UYXJnZXQpIHtcclxuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLnggPSB4O1xyXG4gICAgICAgIHRoaXMueSA9IHk7XHJcbiAgICAgICAgdGhpcy5jb3N0U29GYXIgPSBjb3N0U29GYXI7XHJcbiAgICAgICAgdGhpcy5zaW1wbGVEaXN0YW5jZVRvVGFyZ2V0ID0gc2ltcGxlRGlzdGFuY2VUb1RhcmdldDtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIEByZXR1cm4ge051bWJlcn0gQmVzdCBndWVzcyBkaXN0YW5jZSBvZiBhIGNvc3QgdXNpbmcgdGhpcyBub2RlLlxyXG4gICAgICovXHJcbiAgICBiZXN0R3Vlc3NEaXN0YW5jZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jb3N0U29GYXIgKyB0aGlzLnNpbXBsZURpc3RhbmNlVG9UYXJnZXQ7XHJcbiAgICB9XHJcbn0iLCIvKipcclxuKiAgIEVhc3lTdGFyLmpzXHJcbiogICBnaXRodWIuY29tL3ByZXR0eW11Y2hicnljZS9FYXN5U3RhckpTXHJcbiogICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXHJcbipcclxuKiAgIEltcGxlbWVudGF0aW9uIEJ5IEJyeWNlIE5lYWwgKEBwcmV0dHltdWNoYnJ5Y2UpXHJcbioqL1xyXG5cclxudmFyIEVhc3lTdGFyID0ge31cclxuaW1wb3J0IEluc3RhbmNlIGZyb20gJy4vaW5zdGFuY2UuanMnO1xyXG5pbXBvcnQgTm9kZSBmcm9tICcuL25vZGUuanMnO1xyXG5pbXBvcnQgSGVhcCBmcm9tICdoZWFwJztcclxuXHJcbmNvbnN0IENMT1NFRF9MSVNUID0gMDtcclxuY29uc3QgT1BFTl9MSVNUID0gMTtcclxuXHJcbnZhciBuZXh0SW5zdGFuY2VJZCA9IDE7XHJcblxyXG5FYXN5U3Rhci5qcyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgdmFyIFNUUkFJR0hUX0NPU1QgPSAxLjA7XHJcbiAgICB2YXIgRElBR09OQUxfQ09TVCA9IDEuNDtcclxuICAgIHZhciBzeW5jRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgdmFyIHBvaW50c1RvQXZvaWQgPSB7fTtcclxuICAgIHZhciBjb2xsaXNpb25HcmlkO1xyXG4gICAgdmFyIGNvc3RNYXAgPSB7fTtcclxuICAgIHZhciBwb2ludHNUb0Nvc3QgPSB7fTtcclxuICAgIHZhciBkaXJlY3Rpb25hbENvbmRpdGlvbnMgPSB7fTtcclxuICAgIHZhciBhbGxvd0Nvcm5lckN1dHRpbmcgPSB0cnVlO1xyXG4gICAgdmFyIGl0ZXJhdGlvbnNTb0ZhcjtcclxuICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcclxuICAgIHZhciBpbnN0YW5jZVF1ZXVlID0gW107XHJcbiAgICB2YXIgaXRlcmF0aW9uc1BlckNhbGN1bGF0aW9uID0gTnVtYmVyLk1BWF9WQUxVRTtcclxuICAgIHZhciBhY2NlcHRhYmxlVGlsZXM7XHJcbiAgICB2YXIgZGlhZ29uYWxzRW5hYmxlZCA9IGZhbHNlO1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZXRzIHRoZSBjb2xsaXNpb24gZ3JpZCB0aGF0IEVhc3lTdGFyIHVzZXMuXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7QXJyYXl8TnVtYmVyfSB0aWxlcyBBbiBhcnJheSBvZiBudW1iZXJzIHRoYXQgcmVwcmVzZW50XHJcbiAgICAqIHdoaWNoIHRpbGVzIGluIHlvdXIgZ3JpZCBzaG91bGQgYmUgY29uc2lkZXJlZFxyXG4gICAgKiBhY2NlcHRhYmxlLCBvciBcIndhbGthYmxlXCIuXHJcbiAgICAqKi9cclxuICAgIHRoaXMuc2V0QWNjZXB0YWJsZVRpbGVzID0gZnVuY3Rpb24odGlsZXMpIHtcclxuICAgICAgICBpZiAodGlsZXMgaW5zdGFuY2VvZiBBcnJheSkge1xyXG4gICAgICAgICAgICAvLyBBcnJheVxyXG4gICAgICAgICAgICBhY2NlcHRhYmxlVGlsZXMgPSB0aWxlcztcclxuICAgICAgICB9IGVsc2UgaWYgKCFpc05hTihwYXJzZUZsb2F0KHRpbGVzKSkgJiYgaXNGaW5pdGUodGlsZXMpKSB7XHJcbiAgICAgICAgICAgIC8vIE51bWJlclxyXG4gICAgICAgICAgICBhY2NlcHRhYmxlVGlsZXMgPSBbdGlsZXNdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEVuYWJsZXMgc3luYyBtb2RlIGZvciB0aGlzIEVhc3lTdGFyIGluc3RhbmNlLi5cclxuICAgICogaWYgeW91J3JlIGludG8gdGhhdCBzb3J0IG9mIHRoaW5nLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmVuYWJsZVN5bmMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzeW5jRW5hYmxlZCA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEaXNhYmxlcyBzeW5jIG1vZGUgZm9yIHRoaXMgRWFzeVN0YXIgaW5zdGFuY2UuXHJcbiAgICAqKi9cclxuICAgIHRoaXMuZGlzYWJsZVN5bmMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBzeW5jRW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEVuYWJsZSBkaWFnb25hbCBwYXRoZmluZGluZy5cclxuICAgICAqL1xyXG4gICAgdGhpcy5lbmFibGVEaWFnb25hbHMgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICBkaWFnb25hbHNFbmFibGVkID0gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICAqIERpc2FibGUgZGlhZ29uYWwgcGF0aGZpbmRpbmcuXHJcbiAgICAgKi9cclxuICAgIHRoaXMuZGlzYWJsZURpYWdvbmFscyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGRpYWdvbmFsc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgY29sbGlzaW9uIGdyaWQgdGhhdCBFYXN5U3RhciB1c2VzLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge0FycmF5fSBncmlkIFRoZSBjb2xsaXNpb24gZ3JpZCB0aGF0IHRoaXMgRWFzeVN0YXIgaW5zdGFuY2Ugd2lsbCByZWFkIGZyb20uXHJcbiAgICAqIFRoaXMgc2hvdWxkIGJlIGEgMkQgQXJyYXkgb2YgTnVtYmVycy5cclxuICAgICoqL1xyXG4gICAgdGhpcy5zZXRHcmlkID0gZnVuY3Rpb24oZ3JpZCkge1xyXG4gICAgICAgIGNvbGxpc2lvbkdyaWQgPSBncmlkO1xyXG5cclxuICAgICAgICAvL1NldHVwIGNvc3QgbWFwXHJcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBjb2xsaXNpb25HcmlkLmxlbmd0aDsgeSsrKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgY29sbGlzaW9uR3JpZFswXS5sZW5ndGg7IHgrKykge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFjb3N0TWFwW2NvbGxpc2lvbkdyaWRbeV1beF1dKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29zdE1hcFtjb2xsaXNpb25HcmlkW3ldW3hdXSA9IDFcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgdGhlIHRpbGUgY29zdCBmb3IgYSBwYXJ0aWN1bGFyIHRpbGUgdHlwZS5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFRoZSB0aWxlIHR5cGUgdG8gc2V0IHRoZSBjb3N0IGZvci5cclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IFRoZSBtdWx0aXBsaWNhdGl2ZSBjb3N0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4gdGlsZS5cclxuICAgICoqL1xyXG4gICAgdGhpcy5zZXRUaWxlQ29zdCA9IGZ1bmN0aW9uKHRpbGVUeXBlLCBjb3N0KSB7XHJcbiAgICAgICAgY29zdE1hcFt0aWxlVHlwZV0gPSBjb3N0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU2V0cyB0aGUgYW4gYWRkaXRpb25hbCBjb3N0IGZvciBhIHBhcnRpY3VsYXIgcG9pbnQuXHJcbiAgICAqIE92ZXJyaWRlcyB0aGUgY29zdCBmcm9tIHNldFRpbGVDb3N0LlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCB2YWx1ZSBvZiB0aGUgcG9pbnQgdG8gY29zdC5cclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgdmFsdWUgb2YgdGhlIHBvaW50IHRvIGNvc3QuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBUaGUgbXVsdGlwbGljYXRpdmUgY29zdCBhc3NvY2lhdGVkIHdpdGggdGhlIGdpdmVuIHBvaW50LlxyXG4gICAgKiovXHJcbiAgICB0aGlzLnNldEFkZGl0aW9uYWxQb2ludENvc3QgPSBmdW5jdGlvbih4LCB5LCBjb3N0KSB7XHJcbiAgICAgICAgaWYgKHBvaW50c1RvQ29zdFt5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBvaW50c1RvQ29zdFt5XSA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBwb2ludHNUb0Nvc3RbeV1beF0gPSBjb3N0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlIHRoZSBhZGRpdGlvbmFsIGNvc3QgZm9yIGEgcGFydGljdWxhciBwb2ludC5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggdmFsdWUgb2YgdGhlIHBvaW50IHRvIHN0b3AgY29zdGluZy5cclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgdmFsdWUgb2YgdGhlIHBvaW50IHRvIHN0b3AgY29zdGluZy5cclxuICAgICoqL1xyXG4gICAgdGhpcy5yZW1vdmVBZGRpdGlvbmFsUG9pbnRDb3N0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIGlmIChwb2ludHNUb0Nvc3RbeV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBkZWxldGUgcG9pbnRzVG9Db3N0W3ldW3hdO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlIGFsbCBhZGRpdGlvbmFsIHBvaW50IGNvc3RzLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLnJlbW92ZUFsbEFkZGl0aW9uYWxQb2ludENvc3RzID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcG9pbnRzVG9Db3N0ID0ge307XHJcbiAgICB9XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIFNldHMgYSBkaXJlY3Rpb25hbCBjb25kaXRpb24gb24gYSB0aWxlXHJcbiAgICAqXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IHZhbHVlIG9mIHRoZSBwb2ludC5cclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgdmFsdWUgb2YgdGhlIHBvaW50LlxyXG4gICAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBhbGxvd2VkRGlyZWN0aW9ucyBBIGxpc3Qgb2YgYWxsIHRoZSBhbGxvd2VkIGRpcmVjdGlvbnMgdGhhdCBjYW4gYWNjZXNzXHJcbiAgICAqIHRoZSB0aWxlLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLnNldERpcmVjdGlvbmFsQ29uZGl0aW9uID0gZnVuY3Rpb24oeCwgeSwgYWxsb3dlZERpcmVjdGlvbnMpIHtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uYWxDb25kaXRpb25zW3ldID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgZGlyZWN0aW9uYWxDb25kaXRpb25zW3ldID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRpcmVjdGlvbmFsQ29uZGl0aW9uc1t5XVt4XSA9IGFsbG93ZWREaXJlY3Rpb25zO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogUmVtb3ZlIGFsbCBkaXJlY3Rpb25hbCBjb25kaXRpb25zXHJcbiAgICAqKi9cclxuICAgIHRoaXMucmVtb3ZlQWxsRGlyZWN0aW9uYWxDb25kaXRpb25zID0gZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgZGlyZWN0aW9uYWxDb25kaXRpb25zID0ge307XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTZXRzIHRoZSBudW1iZXIgb2Ygc2VhcmNoIGl0ZXJhdGlvbnMgcGVyIGNhbGN1bGF0aW9uLlxyXG4gICAgKiBBIGxvd2VyIG51bWJlciBwcm92aWRlcyBhIHNsb3dlciByZXN1bHQsIGJ1dCBtb3JlIHByYWN0aWNhbCBpZiB5b3VcclxuICAgICogaGF2ZSBhIGxhcmdlIHRpbGUtbWFwIGFuZCBkb24ndCB3YW50IHRvIGJsb2NrIHlvdXIgdGhyZWFkIHdoaWxlXHJcbiAgICAqIGZpbmRpbmcgYSBwYXRoLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIHNlYXJjaGVzIHRvIHByZWZyb20gcGVyIGNhbGN1bGF0ZSgpIGNhbGwuXHJcbiAgICAqKi9cclxuICAgIHRoaXMuc2V0SXRlcmF0aW9uc1BlckNhbGN1bGF0aW9uID0gZnVuY3Rpb24oaXRlcmF0aW9ucykge1xyXG4gICAgICAgIGl0ZXJhdGlvbnNQZXJDYWxjdWxhdGlvbiA9IGl0ZXJhdGlvbnM7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBBdm9pZCBhIHBhcnRpY3VsYXIgcG9pbnQgb24gdGhlIGdyaWQsXHJcbiAgICAqIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciBvciBub3QgaXQgaXMgYW4gYWNjZXB0YWJsZSB0aWxlLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCB2YWx1ZSBvZiB0aGUgcG9pbnQgdG8gYXZvaWQuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHZhbHVlIG9mIHRoZSBwb2ludCB0byBhdm9pZC5cclxuICAgICoqL1xyXG4gICAgdGhpcy5hdm9pZEFkZGl0aW9uYWxQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICBpZiAocG9pbnRzVG9Bdm9pZFt5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHBvaW50c1RvQXZvaWRbeV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcG9pbnRzVG9Bdm9pZFt5XVt4XSA9IDE7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBTdG9wIGF2b2lkaW5nIGEgcGFydGljdWxhciBwb2ludCBvbiB0aGUgZ3JpZC5cclxuICAgICpcclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggdmFsdWUgb2YgdGhlIHBvaW50IHRvIHN0b3AgYXZvaWRpbmcuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IHZhbHVlIG9mIHRoZSBwb2ludCB0byBzdG9wIGF2b2lkaW5nLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLnN0b3BBdm9pZGluZ0FkZGl0aW9uYWxQb2ludCA9IGZ1bmN0aW9uKHgsIHkpIHtcclxuICAgICAgICBpZiAocG9pbnRzVG9Bdm9pZFt5XSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBwb2ludHNUb0F2b2lkW3ldW3hdO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEVuYWJsZXMgY29ybmVyIGN1dHRpbmcgaW4gZGlhZ29uYWwgbW92ZW1lbnQuXHJcbiAgICAqKi9cclxuICAgIHRoaXMuZW5hYmxlQ29ybmVyQ3V0dGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFsbG93Q29ybmVyQ3V0dGluZyA9IHRydWU7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgKiBEaXNhYmxlcyBjb3JuZXIgY3V0dGluZyBpbiBkaWFnb25hbCBtb3ZlbWVudC5cclxuICAgICoqL1xyXG4gICAgdGhpcy5kaXNhYmxlQ29ybmVyQ3V0dGluZyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGFsbG93Q29ybmVyQ3V0dGluZyA9IGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogU3RvcCBhdm9pZGluZyBhbGwgYWRkaXRpb25hbCBwb2ludHMgb24gdGhlIGdyaWQuXHJcbiAgICAqKi9cclxuICAgIHRoaXMuc3RvcEF2b2lkaW5nQWxsQWRkaXRpb25hbFBvaW50cyA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHBvaW50c1RvQXZvaWQgPSB7fTtcclxuICAgIH07XHJcblxyXG4gICAgLyoqXHJcbiAgICAqIEZpbmQgYSBwYXRoLlxyXG4gICAgKlxyXG4gICAgKiBAcGFyYW0ge051bWJlcn0gc3RhcnRYIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBzdGFydGluZyBwb2ludC5cclxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXJ0WSBUaGUgWSBwb3NpdGlvbiBvZiB0aGUgc3RhcnRpbmcgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRYIFRoZSBYIHBvc2l0aW9uIG9mIHRoZSBlbmRpbmcgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbmRZIFRoZSBZIHBvc2l0aW9uIG9mIHRoZSBlbmRpbmcgcG9pbnQuXHJcbiAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIEEgZnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB5b3VyIHBhdGhcclxuICAgICogaXMgZm91bmQsIG9yIG5vIHBhdGggaXMgZm91bmQuXHJcbiAgICAqIEByZXR1cm4ge051bWJlcn0gQSBudW1lcmljLCBub24temVybyB2YWx1ZSB3aGljaCBpZGVudGlmaWVzIHRoZSBjcmVhdGVkIGluc3RhbmNlLiBUaGlzIHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gY2FuY2VsUGF0aCB0byBjYW5jZWwgdGhlIHBhdGggY2FsY3VsYXRpb24uXHJcbiAgICAqXHJcbiAgICAqKi9cclxuICAgIHRoaXMuZmluZFBhdGggPSBmdW5jdGlvbihzdGFydFgsIHN0YXJ0WSwgZW5kWCwgZW5kWSwgY2FsbGJhY2spIHtcclxuICAgICAgICAvLyBXcmFwcyB0aGUgY2FsbGJhY2sgZm9yIHN5bmMgdnMgYXN5bmMgbG9naWNcclxuICAgICAgICB2YXIgY2FsbGJhY2tXcmFwcGVyID0gZnVuY3Rpb24ocmVzdWx0KSB7XHJcbiAgICAgICAgICAgIGlmIChzeW5jRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBObyBhY2NlcHRhYmxlIHRpbGVzIHdlcmUgc2V0XHJcbiAgICAgICAgaWYgKGFjY2VwdGFibGVUaWxlcyA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBjYW4ndCBzZXQgYSBwYXRoIHdpdGhvdXQgZmlyc3QgY2FsbGluZyBzZXRBY2NlcHRhYmxlVGlsZXMoKSBvbiBFYXN5U3Rhci5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE5vIGdyaWQgd2FzIHNldFxyXG4gICAgICAgIGlmIChjb2xsaXNpb25HcmlkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IGNhbid0IHNldCBhIHBhdGggd2l0aG91dCBmaXJzdCBjYWxsaW5nIHNldEdyaWQoKSBvbiBFYXN5U3Rhci5cIik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTdGFydCBvciBlbmRwb2ludCBvdXRzaWRlIG9mIHNjb3BlLlxyXG4gICAgICAgIGlmIChzdGFydFggPCAwIHx8IHN0YXJ0WSA8IDAgfHwgZW5kWCA8IDAgfHwgZW5kWSA8IDAgfHxcclxuICAgICAgICBzdGFydFggPiBjb2xsaXNpb25HcmlkWzBdLmxlbmd0aC0xIHx8IHN0YXJ0WSA+IGNvbGxpc2lvbkdyaWQubGVuZ3RoLTEgfHxcclxuICAgICAgICBlbmRYID4gY29sbGlzaW9uR3JpZFswXS5sZW5ndGgtMSB8fCBlbmRZID4gY29sbGlzaW9uR3JpZC5sZW5ndGgtMSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3VyIHN0YXJ0IG9yIGVuZCBwb2ludCBpcyBvdXRzaWRlIHRoZSBzY29wZSBvZiB5b3VyIGdyaWQuXCIpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gU3RhcnQgYW5kIGVuZCBhcmUgdGhlIHNhbWUgdGlsZS5cclxuICAgICAgICBpZiAoc3RhcnRYPT09ZW5kWCAmJiBzdGFydFk9PT1lbmRZKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrV3JhcHBlcihbXSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIEVuZCBwb2ludCBpcyBub3QgYW4gYWNjZXB0YWJsZSB0aWxlLlxyXG4gICAgICAgIHZhciBlbmRUaWxlID0gY29sbGlzaW9uR3JpZFtlbmRZXVtlbmRYXTtcclxuICAgICAgICB2YXIgaXNBY2NlcHRhYmxlID0gZmFsc2U7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRhYmxlVGlsZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGVuZFRpbGUgPT09IGFjY2VwdGFibGVUaWxlc1tpXSkge1xyXG4gICAgICAgICAgICAgICAgaXNBY2NlcHRhYmxlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAoaXNBY2NlcHRhYmxlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgICBjYWxsYmFja1dyYXBwZXIobnVsbCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgaW5zdGFuY2VcclxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgSW5zdGFuY2UoKTtcclxuICAgICAgICBpbnN0YW5jZS5vcGVuTGlzdCA9IG5ldyBIZWFwKGZ1bmN0aW9uKG5vZGVBLCBub2RlQikge1xyXG4gICAgICAgICAgICByZXR1cm4gbm9kZUEuYmVzdEd1ZXNzRGlzdGFuY2UoKSAtIG5vZGVCLmJlc3RHdWVzc0Rpc3RhbmNlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaW5zdGFuY2UuaXNEb25lQ2FsY3VsYXRpbmcgPSBmYWxzZTtcclxuICAgICAgICBpbnN0YW5jZS5ub2RlSGFzaCA9IHt9O1xyXG4gICAgICAgIGluc3RhbmNlLnN0YXJ0WCA9IHN0YXJ0WDtcclxuICAgICAgICBpbnN0YW5jZS5zdGFydFkgPSBzdGFydFk7XHJcbiAgICAgICAgaW5zdGFuY2UuZW5kWCA9IGVuZFg7XHJcbiAgICAgICAgaW5zdGFuY2UuZW5kWSA9IGVuZFk7XHJcbiAgICAgICAgaW5zdGFuY2UuY2FsbGJhY2sgPSBjYWxsYmFja1dyYXBwZXI7XHJcblxyXG4gICAgICAgIGluc3RhbmNlLm9wZW5MaXN0LnB1c2goY29vcmRpbmF0ZVRvTm9kZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhcnRYLFxyXG4gICAgICAgICAgICBpbnN0YW5jZS5zdGFydFksIG51bGwsIFNUUkFJR0hUX0NPU1QpKTtcclxuXHJcbiAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBuZXh0SW5zdGFuY2VJZCArKztcclxuICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcclxuICAgICAgICBpbnN0YW5jZVF1ZXVlLnB1c2goaW5zdGFuY2VJZCk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlSWQ7XHJcbiAgICB9O1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ2FuY2VsIGEgcGF0aCBjYWxjdWxhdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaW5zdGFuY2VJZCBUaGUgaW5zdGFuY2UgSUQgb2YgdGhlIHBhdGggYmVpbmcgY2FsY3VsYXRlZFxyXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBhbiBpbnN0YW5jZSB3YXMgZm91bmQgYW5kIGNhbmNlbGxlZC5cclxuICAgICAqXHJcbiAgICAgKiovXHJcbiAgICB0aGlzLmNhbmNlbFBhdGggPSBmdW5jdGlvbihpbnN0YW5jZUlkKSB7XHJcbiAgICAgICAgaWYgKGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gcmVtb3ZlIGl0IGZyb20gaW5zdGFuY2VRdWV1ZVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICogVGhpcyBtZXRob2Qgc3RlcHMgdGhyb3VnaCB0aGUgQSogQWxnb3JpdGhtIGluIGFuIGF0dGVtcHQgdG9cclxuICAgICogZmluZCB5b3VyIHBhdGgocykuIEl0IHdpbGwgc2VhcmNoIDQtOCB0aWxlcyAoZGVwZW5kaW5nIG9uIGRpYWdvbmFscykgZm9yIGV2ZXJ5IGNhbGN1bGF0aW9uLlxyXG4gICAgKiBZb3UgY2FuIGNoYW5nZSB0aGUgbnVtYmVyIG9mIGNhbGN1bGF0aW9ucyBkb25lIGluIGEgY2FsbCBieSB1c2luZ1xyXG4gICAgKiBlYXN5c3Rhci5zZXRJdGVyYXRvbnNQZXJDYWxjdWxhdGlvbigpLlxyXG4gICAgKiovXHJcbiAgICB0aGlzLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIGlmIChpbnN0YW5jZVF1ZXVlLmxlbmd0aCA9PT0gMCB8fCBjb2xsaXNpb25HcmlkID09PSB1bmRlZmluZWQgfHwgYWNjZXB0YWJsZVRpbGVzID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGl0ZXJhdGlvbnNTb0ZhciA9IDA7IGl0ZXJhdGlvbnNTb0ZhciA8IGl0ZXJhdGlvbnNQZXJDYWxjdWxhdGlvbjsgaXRlcmF0aW9uc1NvRmFyKyspIHtcclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlUXVldWUubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGlmIChzeW5jRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHN5bmMgaW5zdGFuY2UsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQgY2FsY3VsYXRlcyBzeW5jaHJvbm91c2x5LlxyXG4gICAgICAgICAgICAgICAgaXRlcmF0aW9uc1NvRmFyID0gMDtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBpbnN0YW5jZVF1ZXVlWzBdO1xyXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UgPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaW5zdGFuY2Ugd2FzIGNhbmNlbGxlZFxyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VRdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIENvdWxkbid0IGZpbmQgYSBwYXRoLlxyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2Uub3Blbkxpc3Quc2l6ZSgpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jYWxsYmFjayhudWxsKTtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVF1ZXVlLnNoaWZ0KCk7XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdmFyIHNlYXJjaE5vZGUgPSBpbnN0YW5jZS5vcGVuTGlzdC5wb3AoKTtcclxuXHJcbiAgICAgICAgICAgIC8vIEhhbmRsZXMgdGhlIGNhc2Ugd2hlcmUgd2UgaGF2ZSBmb3VuZCB0aGUgZGVzdGluYXRpb25cclxuICAgICAgICAgICAgaWYgKGluc3RhbmNlLmVuZFggPT09IHNlYXJjaE5vZGUueCAmJiBpbnN0YW5jZS5lbmRZID09PSBzZWFyY2hOb2RlLnkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBwYXRoID0gW107XHJcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goe3g6IHNlYXJjaE5vZGUueCwgeTogc2VhcmNoTm9kZS55fSk7XHJcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gc2VhcmNoTm9kZS5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB3aGlsZSAocGFyZW50IT1udWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKHt4OiBwYXJlbnQueCwgeTpwYXJlbnQueX0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnQ7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBwYXRoLnJldmVyc2UoKTtcclxuICAgICAgICAgICAgICAgIHZhciBpcCA9IHBhdGg7XHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZS5jYWxsYmFjayhpcCk7XHJcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2VRdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHNlYXJjaE5vZGUubGlzdCA9IENMT1NFRF9MSVNUO1xyXG5cclxuICAgICAgICAgICAgaWYgKHNlYXJjaE5vZGUueSA+IDApIHtcclxuICAgICAgICAgICAgICAgIGNoZWNrQWRqYWNlbnROb2RlKGluc3RhbmNlLCBzZWFyY2hOb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIDAsIC0xLCBTVFJBSUdIVF9DT1NUICogZ2V0VGlsZUNvc3Qoc2VhcmNoTm9kZS54LCBzZWFyY2hOb2RlLnktMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hOb2RlLnggPCBjb2xsaXNpb25HcmlkWzBdLmxlbmd0aC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FkamFjZW50Tm9kZShpbnN0YW5jZSwgc2VhcmNoTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAxLCAwLCBTVFJBSUdIVF9DT1NUICogZ2V0VGlsZUNvc3Qoc2VhcmNoTm9kZS54KzEsIHNlYXJjaE5vZGUueSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hOb2RlLnkgPCBjb2xsaXNpb25HcmlkLmxlbmd0aC0xKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FkamFjZW50Tm9kZShpbnN0YW5jZSwgc2VhcmNoTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAwLCAxLCBTVFJBSUdIVF9DT1NUICogZ2V0VGlsZUNvc3Qoc2VhcmNoTm9kZS54LCBzZWFyY2hOb2RlLnkrMSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChzZWFyY2hOb2RlLnggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBjaGVja0FkamFjZW50Tm9kZShpbnN0YW5jZSwgc2VhcmNoTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAtMSwgMCwgU1RSQUlHSFRfQ09TVCAqIGdldFRpbGVDb3N0KHNlYXJjaE5vZGUueC0xLCBzZWFyY2hOb2RlLnkpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoZGlhZ29uYWxzRW5hYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaE5vZGUueCA+IDAgJiYgc2VhcmNoTm9kZS55ID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dDb3JuZXJDdXR0aW5nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc1RpbGVXYWxrYWJsZShjb2xsaXNpb25HcmlkLCBhY2NlcHRhYmxlVGlsZXMsIHNlYXJjaE5vZGUueCwgc2VhcmNoTm9kZS55LTEsIHNlYXJjaE5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGlsZVdhbGthYmxlKGNvbGxpc2lvbkdyaWQsIGFjY2VwdGFibGVUaWxlcywgc2VhcmNoTm9kZS54LTEsIHNlYXJjaE5vZGUueSwgc2VhcmNoTm9kZSkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0FkamFjZW50Tm9kZShpbnN0YW5jZSwgc2VhcmNoTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xLCAtMSwgRElBR09OQUxfQ09TVCAqIGdldFRpbGVDb3N0KHNlYXJjaE5vZGUueC0xLCBzZWFyY2hOb2RlLnktMSkpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hOb2RlLnggPCBjb2xsaXNpb25HcmlkWzBdLmxlbmd0aC0xICYmIHNlYXJjaE5vZGUueSA8IGNvbGxpc2lvbkdyaWQubGVuZ3RoLTEpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFsbG93Q29ybmVyQ3V0dGluZyB8fFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAoaXNUaWxlV2Fsa2FibGUoY29sbGlzaW9uR3JpZCwgYWNjZXB0YWJsZVRpbGVzLCBzZWFyY2hOb2RlLngsIHNlYXJjaE5vZGUueSsxLCBzZWFyY2hOb2RlKSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1RpbGVXYWxrYWJsZShjb2xsaXNpb25HcmlkLCBhY2NlcHRhYmxlVGlsZXMsIHNlYXJjaE5vZGUueCsxLCBzZWFyY2hOb2RlLnksIHNlYXJjaE5vZGUpKSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tBZGphY2VudE5vZGUoaW5zdGFuY2UsIHNlYXJjaE5vZGUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAxLCAxLCBESUFHT05BTF9DT1NUICogZ2V0VGlsZUNvc3Qoc2VhcmNoTm9kZS54KzEsIHNlYXJjaE5vZGUueSsxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaE5vZGUueCA8IGNvbGxpc2lvbkdyaWRbMF0ubGVuZ3RoLTEgJiYgc2VhcmNoTm9kZS55ID4gMCkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dDb3JuZXJDdXR0aW5nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc1RpbGVXYWxrYWJsZShjb2xsaXNpb25HcmlkLCBhY2NlcHRhYmxlVGlsZXMsIHNlYXJjaE5vZGUueCwgc2VhcmNoTm9kZS55LTEsIHNlYXJjaE5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGlsZVdhbGthYmxlKGNvbGxpc2lvbkdyaWQsIGFjY2VwdGFibGVUaWxlcywgc2VhcmNoTm9kZS54KzEsIHNlYXJjaE5vZGUueSwgc2VhcmNoTm9kZSkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0FkamFjZW50Tm9kZShpbnN0YW5jZSwgc2VhcmNoTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDEsIC0xLCBESUFHT05BTF9DT1NUICogZ2V0VGlsZUNvc3Qoc2VhcmNoTm9kZS54KzEsIHNlYXJjaE5vZGUueS0xKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaE5vZGUueCA+IDAgJiYgc2VhcmNoTm9kZS55IDwgY29sbGlzaW9uR3JpZC5sZW5ndGgtMSkge1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsb3dDb3JuZXJDdXR0aW5nIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIChpc1RpbGVXYWxrYWJsZShjb2xsaXNpb25HcmlkLCBhY2NlcHRhYmxlVGlsZXMsIHNlYXJjaE5vZGUueCwgc2VhcmNoTm9kZS55KzEsIHNlYXJjaE5vZGUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVGlsZVdhbGthYmxlKGNvbGxpc2lvbkdyaWQsIGFjY2VwdGFibGVUaWxlcywgc2VhcmNoTm9kZS54LTEsIHNlYXJjaE5vZGUueSwgc2VhcmNoTm9kZSkpKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja0FkamFjZW50Tm9kZShpbnN0YW5jZSwgc2VhcmNoTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0xLCAxLCBESUFHT05BTF9DT1NUICogZ2V0VGlsZUNvc3Qoc2VhcmNoTm9kZS54LTEsIHNlYXJjaE5vZGUueSsxKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gUHJpdmF0ZSBtZXRob2RzIGZvbGxvd1xyXG4gICAgdmFyIGNoZWNrQWRqYWNlbnROb2RlID0gZnVuY3Rpb24oaW5zdGFuY2UsIHNlYXJjaE5vZGUsIHgsIHksIGNvc3QpIHtcclxuICAgICAgICB2YXIgYWRqYWNlbnRDb29yZGluYXRlWCA9IHNlYXJjaE5vZGUueCt4O1xyXG4gICAgICAgIHZhciBhZGphY2VudENvb3JkaW5hdGVZID0gc2VhcmNoTm9kZS55K3k7XHJcblxyXG4gICAgICAgIGlmICgocG9pbnRzVG9Bdm9pZFthZGphY2VudENvb3JkaW5hdGVZXSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgICAgICAgICBwb2ludHNUb0F2b2lkW2FkamFjZW50Q29vcmRpbmF0ZVldW2FkamFjZW50Q29vcmRpbmF0ZVhdID09PSB1bmRlZmluZWQpICYmXHJcbiAgICAgICAgICAgIGlzVGlsZVdhbGthYmxlKGNvbGxpc2lvbkdyaWQsIGFjY2VwdGFibGVUaWxlcywgYWRqYWNlbnRDb29yZGluYXRlWCwgYWRqYWNlbnRDb29yZGluYXRlWSwgc2VhcmNoTm9kZSkpIHtcclxuICAgICAgICAgICAgdmFyIG5vZGUgPSBjb29yZGluYXRlVG9Ob2RlKGluc3RhbmNlLCBhZGphY2VudENvb3JkaW5hdGVYLFxyXG4gICAgICAgICAgICAgICAgYWRqYWNlbnRDb29yZGluYXRlWSwgc2VhcmNoTm9kZSwgY29zdCk7XHJcblxyXG4gICAgICAgICAgICBpZiAobm9kZS5saXN0ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUubGlzdCA9IE9QRU5fTElTVDtcclxuICAgICAgICAgICAgICAgIGluc3RhbmNlLm9wZW5MaXN0LnB1c2gobm9kZSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2VhcmNoTm9kZS5jb3N0U29GYXIgKyBjb3N0IDwgbm9kZS5jb3N0U29GYXIpIHtcclxuICAgICAgICAgICAgICAgIG5vZGUuY29zdFNvRmFyID0gc2VhcmNoTm9kZS5jb3N0U29GYXIgKyBjb3N0O1xyXG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQgPSBzZWFyY2hOb2RlO1xyXG4gICAgICAgICAgICAgICAgaW5zdGFuY2Uub3Blbkxpc3QudXBkYXRlSXRlbShub2RlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgLy8gSGVscGVyc1xyXG4gICAgdmFyIGlzVGlsZVdhbGthYmxlID0gZnVuY3Rpb24oY29sbGlzaW9uR3JpZCwgYWNjZXB0YWJsZVRpbGVzLCB4LCB5LCBzb3VyY2VOb2RlKSB7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbmFsQ29uZGl0aW9uID0gZGlyZWN0aW9uYWxDb25kaXRpb25zW3ldICYmIGRpcmVjdGlvbmFsQ29uZGl0aW9uc1t5XVt4XTtcclxuICAgICAgICBpZiAoZGlyZWN0aW9uYWxDb25kaXRpb24pIHtcclxuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGNhbGN1bGF0ZURpcmVjdGlvbihzb3VyY2VOb2RlLnggLSB4LCBzb3VyY2VOb2RlLnkgLSB5KVxyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uSW5jbHVkZWQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpcmVjdGlvbmFsQ29uZGl0aW9uLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbmFsQ29uZGl0aW9uW2ldID09PSBkaXJlY3Rpb24pIHJldHVybiB0cnVlXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIWRpcmVjdGlvbkluY2x1ZGVkKCkpIHJldHVybiBmYWxzZVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdGFibGVUaWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uR3JpZFt5XVt4XSA9PT0gYWNjZXB0YWJsZVRpbGVzW2ldKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIC0xLCAtMSB8IDAsIC0xICB8IDEsIC0xXHJcbiAgICAgKiAtMSwgIDAgfCBTT1VSQ0UgfCAxLCAgMFxyXG4gICAgICogLTEsICAxIHwgMCwgIDEgIHwgMSwgIDFcclxuICAgICAqL1xyXG4gICAgdmFyIGNhbGN1bGF0ZURpcmVjdGlvbiA9IGZ1bmN0aW9uIChkaWZmWCwgZGlmZlkpIHtcclxuICAgICAgICBpZiAoZGlmZlggPT09IDAgJiYgZGlmZlkgPT09IC0xKSByZXR1cm4gRWFzeVN0YXIuVE9QXHJcbiAgICAgICAgZWxzZSBpZiAoZGlmZlggPT09IDEgJiYgZGlmZlkgPT09IC0xKSByZXR1cm4gRWFzeVN0YXIuVE9QX1JJR0hUXHJcbiAgICAgICAgZWxzZSBpZiAoZGlmZlggPT09IDEgJiYgZGlmZlkgPT09IDApIHJldHVybiBFYXN5U3Rhci5SSUdIVFxyXG4gICAgICAgIGVsc2UgaWYgKGRpZmZYID09PSAxICYmIGRpZmZZID09PSAxKSByZXR1cm4gRWFzeVN0YXIuQk9UVE9NX1JJR0hUXHJcbiAgICAgICAgZWxzZSBpZiAoZGlmZlggPT09IDAgJiYgZGlmZlkgPT09IDEpIHJldHVybiBFYXN5U3Rhci5CT1RUT01cclxuICAgICAgICBlbHNlIGlmIChkaWZmWCA9PT0gLTEgJiYgZGlmZlkgPT09IDEpIHJldHVybiBFYXN5U3Rhci5CT1RUT01fTEVGVFxyXG4gICAgICAgIGVsc2UgaWYgKGRpZmZYID09PSAtMSAmJiBkaWZmWSA9PT0gMCkgcmV0dXJuIEVhc3lTdGFyLkxFRlRcclxuICAgICAgICBlbHNlIGlmIChkaWZmWCA9PT0gLTEgJiYgZGlmZlkgPT09IC0xKSByZXR1cm4gRWFzeVN0YXIuVE9QX0xFRlRcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZXNlIGRpZmZlcmVuY2VzIGFyZSBub3QgdmFsaWQ6ICcgKyBkaWZmWCArICcsICcgKyBkaWZmWSlcclxuICAgIH07XHJcblxyXG4gICAgdmFyIGdldFRpbGVDb3N0ID0gZnVuY3Rpb24oeCwgeSkge1xyXG4gICAgICAgIHJldHVybiAocG9pbnRzVG9Db3N0W3ldICYmIHBvaW50c1RvQ29zdFt5XVt4XSkgfHwgY29zdE1hcFtjb2xsaXNpb25HcmlkW3ldW3hdXVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgY29vcmRpbmF0ZVRvTm9kZSA9IGZ1bmN0aW9uKGluc3RhbmNlLCB4LCB5LCBwYXJlbnQsIGNvc3QpIHtcclxuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZUhhc2hbeV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZUhhc2hbeV1beF0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlLm5vZGVIYXNoW3ldW3hdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgaW5zdGFuY2Uubm9kZUhhc2hbeV0gPSB7fTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNpbXBsZURpc3RhbmNlVG9UYXJnZXQgPSBnZXREaXN0YW5jZSh4LCB5LCBpbnN0YW5jZS5lbmRYLCBpbnN0YW5jZS5lbmRZKTtcclxuICAgICAgICBpZiAocGFyZW50IT09bnVsbCkge1xyXG4gICAgICAgICAgICB2YXIgY29zdFNvRmFyID0gcGFyZW50LmNvc3RTb0ZhciArIGNvc3Q7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY29zdFNvRmFyID0gMDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIG5vZGUgPSBuZXcgTm9kZShwYXJlbnQseCx5LGNvc3RTb0ZhcixzaW1wbGVEaXN0YW5jZVRvVGFyZ2V0KTtcclxuICAgICAgICBpbnN0YW5jZS5ub2RlSGFzaFt5XVt4XSA9IG5vZGU7XHJcbiAgICAgICAgcmV0dXJuIG5vZGU7XHJcbiAgICB9O1xyXG5cclxuICAgIHZhciBnZXREaXN0YW5jZSA9IGZ1bmN0aW9uKHgxLHkxLHgyLHkyKSB7XHJcbiAgICAgICAgaWYgKGRpYWdvbmFsc0VuYWJsZWQpIHtcclxuICAgICAgICAgICAgLy8gT2N0aWxlIGRpc3RhbmNlXHJcbiAgICAgICAgICAgIHZhciBkeCA9IE1hdGguYWJzKHgxIC0geDIpO1xyXG4gICAgICAgICAgICB2YXIgZHkgPSBNYXRoLmFicyh5MSAtIHkyKTtcclxuICAgICAgICAgICAgaWYgKGR4IDwgZHkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBESUFHT05BTF9DT1NUICogZHggKyBkeTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBESUFHT05BTF9DT1NUICogZHkgKyBkeDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIC8vIE1hbmhhdHRhbiBkaXN0YW5jZVxyXG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4MSAtIHgyKTtcclxuICAgICAgICAgICAgdmFyIGR5ID0gTWF0aC5hYnMoeTEgLSB5Mik7XHJcbiAgICAgICAgICAgIHJldHVybiAoZHggKyBkeSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5cclxuRWFzeVN0YXIuVE9QID0gJ1RPUCdcclxuRWFzeVN0YXIuVE9QX1JJR0hUID0gJ1RPUF9SSUdIVCdcclxuRWFzeVN0YXIuUklHSFQgPSAnUklHSFQnXHJcbkVhc3lTdGFyLkJPVFRPTV9SSUdIVCA9ICdCT1RUT01fUklHSFQnXHJcbkVhc3lTdGFyLkJPVFRPTSA9ICdCT1RUT00nXHJcbkVhc3lTdGFyLkJPVFRPTV9MRUZUID0gJ0JPVFRPTV9MRUZUJ1xyXG5FYXN5U3Rhci5MRUZUID0gJ0xFRlQnXHJcbkVhc3lTdGFyLlRPUF9MRUZUID0gJ1RPUF9MRUZUJ1xyXG5cclxuZXhwb3J0IHsgRWFzeVN0YXIgfTsiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsIkhlYXAiLCJkZWZhdWx0Q21wIiwiZmxvb3IiLCJoZWFwaWZ5IiwiaGVhcHBvcCIsImhlYXBwdXNoIiwiaGVhcHB1c2hwb3AiLCJoZWFwcmVwbGFjZSIsImluc29ydCIsIm1pbiIsIm5sYXJnZXN0IiwibnNtYWxsZXN0IiwidXBkYXRlSXRlbSIsIl9zaWZ0ZG93biIsIl9zaWZ0dXAiLCJNYXRoIiwieCIsInkiLCJhIiwibG8iLCJoaSIsImNtcCIsIm1pZCIsIkVycm9yIiwibGVuZ3RoIiwic3BsaWNlIiwiYXBwbHkiLCJjb25jYXQiLCJhcnJheSIsIml0ZW0iLCJwdXNoIiwibGFzdGVsdCIsInJldHVybml0ZW0iLCJwb3AiLCJfcmVmIiwiaSIsIl9pIiwiX2xlbiIsIl9yZWYxIiwiX3Jlc3VsdHMiLCJfcmVzdWx0czEiLCJfaiIsInRoaXMiLCJyZXZlcnNlIiwicG9zIiwiaW5kZXhPZiIsIm4iLCJlbGVtIiwicmVzdWx0Iiwic2xpY2UiLCJzb3J0IiwibG9zIiwic3RhcnRwb3MiLCJuZXdpdGVtIiwicGFyZW50IiwicGFyZW50cG9zIiwiY2hpbGRwb3MiLCJlbmRwb3MiLCJyaWdodHBvcyIsIm5vZGVzIiwicmVwbGFjZSIsInB1c2hwb3AiLCJwcm90b3R5cGUiLCJwZWVrIiwiY29udGFpbnMiLCJjbGVhciIsImVtcHR5Iiwic2l6ZSIsImNsb25lIiwiaGVhcCIsInRvQXJyYXkiLCJpbnNlcnQiLCJ0b3AiLCJmcm9udCIsImhhcyIsImNvcHkiLCJjYWxsIiwiX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwiY2FjaGVkTW9kdWxlIiwidW5kZWZpbmVkIiwiX193ZWJwYWNrX21vZHVsZXNfXyIsImdldHRlciIsIl9fZXNNb2R1bGUiLCJkIiwiZGVmaW5pdGlvbiIsImtleSIsIm8iLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJnZXQiLCJvYmoiLCJwcm9wIiwiaGFzT3duUHJvcGVydHkiLCJyIiwiU3ltYm9sIiwidG9TdHJpbmdUYWciLCJ2YWx1ZSIsIkVhc3lTdGFyIiwibmV4dEluc3RhbmNlSWQiLCJqcyIsImNvbGxpc2lvbkdyaWQiLCJpdGVyYXRpb25zU29GYXIiLCJhY2NlcHRhYmxlVGlsZXMiLCJzeW5jRW5hYmxlZCIsInBvaW50c1RvQXZvaWQiLCJjb3N0TWFwIiwicG9pbnRzVG9Db3N0IiwiZGlyZWN0aW9uYWxDb25kaXRpb25zIiwiYWxsb3dDb3JuZXJDdXR0aW5nIiwiaW5zdGFuY2VzIiwiaW5zdGFuY2VRdWV1ZSIsIml0ZXJhdGlvbnNQZXJDYWxjdWxhdGlvbiIsIk51bWJlciIsIk1BWF9WQUxVRSIsImRpYWdvbmFsc0VuYWJsZWQiLCJzZXRBY2NlcHRhYmxlVGlsZXMiLCJ0aWxlcyIsIkFycmF5IiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiaXNGaW5pdGUiLCJlbmFibGVTeW5jIiwiZGlzYWJsZVN5bmMiLCJlbmFibGVEaWFnb25hbHMiLCJkaXNhYmxlRGlhZ29uYWxzIiwic2V0R3JpZCIsImdyaWQiLCJzZXRUaWxlQ29zdCIsInRpbGVUeXBlIiwiY29zdCIsInNldEFkZGl0aW9uYWxQb2ludENvc3QiLCJyZW1vdmVBZGRpdGlvbmFsUG9pbnRDb3N0IiwicmVtb3ZlQWxsQWRkaXRpb25hbFBvaW50Q29zdHMiLCJzZXREaXJlY3Rpb25hbENvbmRpdGlvbiIsImFsbG93ZWREaXJlY3Rpb25zIiwicmVtb3ZlQWxsRGlyZWN0aW9uYWxDb25kaXRpb25zIiwic2V0SXRlcmF0aW9uc1BlckNhbGN1bGF0aW9uIiwiaXRlcmF0aW9ucyIsImF2b2lkQWRkaXRpb25hbFBvaW50Iiwic3RvcEF2b2lkaW5nQWRkaXRpb25hbFBvaW50IiwiZW5hYmxlQ29ybmVyQ3V0dGluZyIsImRpc2FibGVDb3JuZXJDdXR0aW5nIiwic3RvcEF2b2lkaW5nQWxsQWRkaXRpb25hbFBvaW50cyIsImZpbmRQYXRoIiwic3RhcnRYIiwic3RhcnRZIiwiZW5kWCIsImVuZFkiLCJjYWxsYmFjayIsImNhbGxiYWNrV3JhcHBlciIsInNldFRpbWVvdXQiLCJlbmRUaWxlIiwiaXNBY2NlcHRhYmxlIiwiaW5zdGFuY2UiLCJJbnN0YW5jZSIsIm9wZW5MaXN0Iiwibm9kZUEiLCJub2RlQiIsImJlc3RHdWVzc0Rpc3RhbmNlIiwiaXNEb25lQ2FsY3VsYXRpbmciLCJub2RlSGFzaCIsImNvb3JkaW5hdGVUb05vZGUiLCJpbnN0YW5jZUlkIiwiY2FuY2VsUGF0aCIsImNhbGN1bGF0ZSIsInNlYXJjaE5vZGUiLCJsaXN0IiwiY2hlY2tBZGphY2VudE5vZGUiLCJnZXRUaWxlQ29zdCIsImlzVGlsZVdhbGthYmxlIiwicGF0aCIsImlwIiwic2hpZnQiLCJhZGphY2VudENvb3JkaW5hdGVYIiwiYWRqYWNlbnRDb29yZGluYXRlWSIsIm5vZGUiLCJjb3N0U29GYXIiLCJzb3VyY2VOb2RlIiwiZGlyZWN0aW9uYWxDb25kaXRpb24iLCJkaXJlY3Rpb24iLCJjYWxjdWxhdGVEaXJlY3Rpb24iLCJkaXJlY3Rpb25JbmNsdWRlZCIsImRpZmZYIiwiZGlmZlkiLCJUT1AiLCJUT1BfUklHSFQiLCJSSUdIVCIsIkJPVFRPTV9SSUdIVCIsIkJPVFRPTSIsIkJPVFRPTV9MRUZUIiwiTEVGVCIsIlRPUF9MRUZUIiwic2ltcGxlRGlzdGFuY2VUb1RhcmdldCIsImdldERpc3RhbmNlIiwiTm9kZSIsIngxIiwieTEiLCJ4MiIsInkyIiwiZHgiLCJkeSIsImFicyJdLCJzb3VyY2VSb290IjoiIn0=